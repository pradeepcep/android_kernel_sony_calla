/*****************************************************************************
 *
 * Filename:
 * ---------
 *	 S5K4H5YCmipi_Sensor.c
 *
 * Project:
 * --------
 *	 ALPS
 *
 * Description:
 * ------------
 *	 Source code of Sensor driver
 *
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

#include <linux/videodev2.h>
#include <linux/i2c.h>
#include <linux/platform_device.h>
#include <linux/delay.h>
#include <linux/cdev.h>
#include <linux/uaccess.h>
#include <linux/fs.h>
#include <asm/atomic.h>
#include <asm/system.h>
#include <linux/xlog.h>

#include "kd_camera_hw.h"
#include "kd_imgsensor.h"
#include "kd_imgsensor_define.h"
#include "kd_imgsensor_errcode.h"

#include "imx134mipiraw_Sensor.h"

#define PFX "IMX134_camera_sensor"
#define LOG_INF(format, args...)	xlog_printk(ANDROID_LOG_INFO   , PFX, "[%s] " format, __FUNCTION__, ##args)
extern int iReadReg(u16 a_u2Addr , u8 * a_puBuff , u16 i2cId);//add by hhl
extern int iWriteReg(u16 a_u2Addr , u32 a_u4Data , u32 a_u4Bytes , u16 i2cId);//add by hhl
#define write_cmos_sensor(addr, para) iWriteReg((u16) addr , (u32) para , 1, imgsensor.i2c_write_id)//add by hhl
static DEFINE_SPINLOCK(imgsensor_drv_lock);
#define IMX134MIPI_MaxGainIndex (97)
kal_uint16 IMX134MIPI_sensorGainMapping[IMX134MIPI_MaxGainIndex][2] ={
{ 64 ,0  },   
{ 68 ,12 },   
{ 71 ,23 },   
{ 74 ,33 },   
{ 77 ,42 },   
{ 81 ,52 },   
{ 84 ,59 },   
{ 87 ,66 },   
{ 90 ,73 },   
{ 93 ,79 },   
{ 96 ,85 },   
{ 100,91 },   
{ 103,96 },   
{ 106,101},   
{ 109,105},   
{ 113,110},   
{ 116,114},   
{ 120,118},   
{ 122,121},   
{ 125,125},   
{ 128,128},   
{ 132,131},   
{ 135,134},   
{ 138,137},
{ 141,139},
{ 144,142},   
{ 148,145},   
{ 151,147},   
{ 153,149}, 
{ 157,151},
{ 160,153},      
{ 164,156},   
{ 168,158},   
{ 169,159},   
{ 173,161},   
{ 176,163},   
{ 180,165}, 
{ 182,166},   
{ 187,168},
{ 189,169},
{ 193,171},
{ 196,172},
{ 200,174},
{ 203,175}, 
{ 205,176},
{ 208,177}, 
{ 213,179}, //134==>179 yyf
{ 216,180},  
{ 219,181},   
{ 222,182},
{ 225,183},  
{ 228,184},   
{ 232,185},
{ 235,186},
{ 238,187},
{ 241,188},
{ 245,189},
{ 249,190},
{ 253,191},
{ 256,192}, 
{ 260,193},
{ 265,194},
{ 269,195},
{ 274,196},   
{ 278,197},
{ 283,198},
{ 288,199},
{ 293,200},
{ 298,201},   
{ 304,202},   
{ 310,203},
{ 315,204},
{ 322,205},   
{ 328,206},   
{ 335,207},   
{ 342,208},   
{ 349,209},   
{ 357,210},   
{ 365,211},   
{ 373,212}, 
{ 381,213},
{ 400,215},      
{ 420,217},   
{ 432,218},   
{ 443,219},      
{ 468,221},   
{ 482,222},   
{ 497,223},   
{ 512,224},
{ 529,225}, 	 
{ 546,226},   
{ 566,227},   
{ 585,228}, 	 
{ 607,229},   
{ 631,230},   
{ 656,231},   
{ 683,232}
};

static imgsensor_info_struct imgsensor_info = { 
	.sensor_id = IMX134_SENSOR_ID,
	
	.checksum_value = 0x9657b9f1,
	
	.pre = {
		.pclk =199600000 ,
		.linelength = 3600,
		.framelength = 1848,
		.startx = 0,
		.starty = 0,
		.grabwindow_width = 1640,		//record different mode's width of grabwindow
		.grabwindow_height = 1232,		//record different mode's height of grabwindow
		/*	 following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario	*/
		.mipi_data_lp2hs_settle_dc = 14,
		/*	 following for GetDefaultFramerateByScenario()	*/
		.max_framerate = 300,	
	},
	.cap = {
		.pclk = 199600000,
		.linelength = 3600,
		.framelength = 2520,
		.startx = 0,
		.starty = 0,
		.grabwindow_width = 3280,
		.grabwindow_height = 2464,
		.mipi_data_lp2hs_settle_dc = 14,
		.max_framerate = 300,
	},
	.cap1 = {
		.pclk = 199600000,
		.linelength = 3600,
		.framelength = 2520,
		.startx = 0,
		.starty = 0,
		.grabwindow_width = 3280,
		.grabwindow_height = 2464,
		.mipi_data_lp2hs_settle_dc = 14,
		.max_framerate = 300,
	},
	.normal_video = {
		.pclk = 199600000,
		.linelength = 3600,
		.framelength = 2520,
		.startx = 0,
		.starty = 0,
		.grabwindow_width = 1640,
		.grabwindow_height = 1232,
		.mipi_data_lp2hs_settle_dc = 14,
		.max_framerate = 300,
	},
	.hs_video = {
		.pclk = 199600000,
		.linelength = 3600,
		.framelength = 2520,
		.startx = 0,
		.starty = 0,
		.grabwindow_width = 1640,
		.grabwindow_height = 1232,
		.mipi_data_lp2hs_settle_dc = 14,
		.max_framerate = 300,
	},
	.slim_video = {
		.pclk = 199600000,
		.linelength = 3600,
		.framelength = 2520,
		.startx = 0,
		.starty = 0,
		.grabwindow_width = 1640,
		.grabwindow_height = 1232,
		.mipi_data_lp2hs_settle_dc = 14,
		.max_framerate = 300,
	},
	.margin = 4,
	.min_shutter = 4,
	.max_frame_length = 0xffff,
	.ae_shut_delay_frame = 0,
	.ae_sensor_gain_delay_frame = 0,
	.ae_ispGain_delay_frame = 2,
	.ihdr_support = 0,	  //1, support; 0,not support
	.ihdr_le_firstline = 0,  //1,le first ; 0, se first
	.sensor_mode_num = 3,	  //support sensor mode num
	
	.cap_delay_frame= 2, 
	.pre_delay_frame = 2, 
	.video_delay_frame = 2,
	.hs_video_delay_frame = 2,
	.slim_video_delay_frame = 2,
	
	.isp_driving_current = ISP_DRIVING_8MA,
	.sensor_interface_type = SENSOR_INTERFACE_TYPE_MIPI,
        /*[Vince] S 180 rotation*/
        #if 0
	.sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_R,
        #else
	.sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_B,
        #endif
        /*[Vince] E 180 rotation*/
	.mclk = 24,
	.mipi_lane_num = SENSOR_MIPI_2_LANE,
	.i2c_addr_table = {0x20},
};


static imgsensor_struct imgsensor = {
	.mirror = IMAGE_NORMAL,				//mirrorflip information
	.sensor_mode = IMGSENSOR_MODE_INIT, //IMGSENSOR_MODE enum value,record current sensor mode,such as: INIT, Preview, Capture, Video,High Speed Video, Slim Video
	.shutter = 0x3D0,					//current shutter
	.gain = 0x100,						//current gain
	.dummy_pixel = 0,					//current dummypixel
	.dummy_line = 0,					//current dummyline
    .current_fps = 30,  //full size current fps : 24fps for PIP, 30fps for Normal or ZSD
    .autoflicker_en = KAL_TRUE,  //auto flicker enable: KAL_FALSE for disable auto flicker, KAL_TRUE for enable auto flicker
	.test_pattern = KAL_FALSE,		//test pattern mode or not. KAL_TRUE for in test pattern mode, KAL_FALSE for normal output
	.current_scenario_id = MSDK_SCENARIO_ID_CAMERA_PREVIEW,//current scenario id
	.ihdr_en = 0, //sensor need support LE, SE with HDR feature
	.i2c_write_id = 0x20,
};


/* Sensor output window information */
static SENSOR_WINSIZE_INFO_STRUCT imgsensor_winsize_info[5] =	 
{{ 2624, 1956,	  8,	2, 2608, 1952, 1296,  972, 0000, 0000, 1296,  972,	  2,	2, 1280,  960}, // Preview 
 { 2624, 1956,	 16,	6, 2592, 1944, 2592, 1944, 0000, 0000, 2592, 1944,	  2,	2, 2560, 1920}, // capture 
 { 2624, 1956,	 16,	6, 2592, 1944, 2592, 1944, 0000, 0000, 2592, 1944,	  3,	3, 2560, 1920}, // video 
 { 2624, 1956,	  2,  250, 2620, 1456, 1920, 1080, 0000, 0000, 1920, 1080,	  2,	2, 1920, 1080}, //hight speed video 
 { 2624, 1956,	  8,  246, 2608, 1460, 1280,  720, 0000, 0000, 1280,  720,	  2,	2, 1280,  720}};// slim video 


static kal_uint16 read_cmos_sensor(kal_uint32 addr)
{
	kal_uint16 get_byte=0;
    iReadReg((u16) addr ,(u8*)&get_byte,imgsensor.i2c_write_id);
    return get_byte;
}


static void set_dummy()
{
	LOG_INF("dummyline = %d, dummypixels = %d \n", imgsensor.dummy_line, imgsensor.dummy_pixel);
	write_cmos_sensor(0x0104, 1);			
	write_cmos_sensor(0x0340, imgsensor.frame_length >> 8);
	write_cmos_sensor(0x0341, imgsensor.frame_length & 0xFF);	  
	write_cmos_sensor(0x0342, imgsensor.line_length >> 8);
	write_cmos_sensor(0x0343, imgsensor.line_length & 0xFF);
    write_cmos_sensor(0x0104, 0);
}
		

static void set_max_framerate(UINT16 framerate,kal_bool min_framelength_en)
{
	kal_int16 dummy_line;
	kal_uint32 frame_length = imgsensor.frame_length;
	//unsigned long flags;

	LOG_INF("framerate = %d, min framelength should enable? \n", framerate,min_framelength_en);
   
	frame_length = imgsensor.pclk / framerate * 10 / imgsensor.line_length;
	spin_lock(&imgsensor_drv_lock);
	imgsensor.frame_length = (frame_length > imgsensor.min_frame_length) ? frame_length : imgsensor.min_frame_length; 
	imgsensor.dummy_line = imgsensor.frame_length - imgsensor.min_frame_length;
	//dummy_line = frame_length - imgsensor.min_frame_length;
	//if (dummy_line < 0)
		//imgsensor.dummy_line = 0;
	//else
		//imgsensor.dummy_line = dummy_line;
	//imgsensor.frame_length = frame_length + imgsensor.dummy_line;
	if (imgsensor.frame_length > imgsensor_info.max_frame_length)
	{
		imgsensor.frame_length = imgsensor_info.max_frame_length;
		imgsensor.dummy_line = imgsensor.frame_length - imgsensor.min_frame_length;
	}
	if (min_framelength_en)
		imgsensor.min_frame_length = imgsensor.frame_length;
	spin_unlock(&imgsensor_drv_lock);
	set_dummy();
}	/*	set_max_framerate  */


static void write_shutter(kal_uint16 shutter)
	{
		kal_uint16 realtime_fps = 0;
		kal_uint32 frame_length = 0;
		// shutter=2512;//add for debug capture framerate  
		/* 0x3500, 0x3501, 0x3502 will increase VBLANK to get exposure larger than frame exposure */
		/* AE doesn't update sensor gain at capture mode, thus extra exposure lines must be updated here. */
		
		// OV Recommend Solution
		// if shutter bigger than frame_length, should extend frame length first
		spin_lock(&imgsensor_drv_lock);
		if (shutter > imgsensor.min_frame_length - imgsensor_info.margin)		
			imgsensor.frame_length = shutter + imgsensor_info.margin;
		else
			imgsensor.frame_length = imgsensor.min_frame_length;
		if (imgsensor.frame_length > imgsensor_info.max_frame_length)
			imgsensor.frame_length = imgsensor_info.max_frame_length;
		spin_unlock(&imgsensor_drv_lock);
		if (shutter < imgsensor_info.min_shutter) shutter = imgsensor_info.min_shutter;
		
		if (imgsensor.autoflicker_en) { 
			realtime_fps = imgsensor.pclk / imgsensor.line_length * 10 / imgsensor.frame_length;
			if(realtime_fps >= 297 && realtime_fps <= 305)
				set_max_framerate(296,0);
			else if(realtime_fps >= 147 && realtime_fps <= 150)
				set_max_framerate(146,0);	
		} else {
			// Extend frame length
			write_cmos_sensor(0x0104, 1);		
			write_cmos_sensor(0x0340, imgsensor.frame_length >> 8);
			write_cmos_sensor(0x0341, imgsensor.frame_length & 0xFF);
            write_cmos_sensor(0x0104, 0);    
		}
	
		// Update Shutter
		write_cmos_sensor(0x0104, 1);		
		write_cmos_sensor(0x0202, (shutter >> 8) & 0xFF); 
 		write_cmos_sensor(0x0203, shutter  & 0xFF);
		write_cmos_sensor(0x0104, 0);	
		LOG_INF("shutter =%d, framelength =%d\n", shutter,imgsensor.frame_length);
	
		//LOG_INF("frame_length = %d ", frame_length);
		
	}




/*************************************************************************
* FUNCTION
*	set_shutter
*
* DESCRIPTION
*	This function set e-shutter of sensor to change exposure time.
*
* PARAMETERS
*	iShutter : exposured lines
*
* RETURNS
*	None
*
* GLOBALS AFFECTED
*
*************************************************************************/
static void set_shutter(kal_uint16 shutter)
{
	unsigned long flags;
	spin_lock_irqsave(&imgsensor_drv_lock, flags);
	imgsensor.shutter = shutter;
	spin_unlock_irqrestore(&imgsensor_drv_lock, flags);
	write_shutter(shutter);
}	/*	set_shutter */



static kal_uint16 gain2reg(const kal_uint16 gain)
	{
		kal_uint8 iI;
		LOG_INF("[IMX134MIPI]enter IMX134MIPIGain2Reg function\n");
		for (iI = 0; iI < (IMX134MIPI_MaxGainIndex-1); iI++) 
		{
			if(gain <IMX134MIPI_sensorGainMapping[iI][0])
			{	 
				break;
			}
			if(gain < IMX134MIPI_sensorGainMapping[iI][0])
			{				 
				return IMX134MIPI_sensorGainMapping[iI][1]; 	  
			}
				
		}
		if(gain != IMX134MIPI_sensorGainMapping[iI][0])
		{
			 LOG_INF("[IMX134MIPIGain2Reg] Gain mapping don't correctly:%d %d \n", gain, IMX134MIPI_sensorGainMapping[iI][0]);
		}
		LOG_INF("[IMX134MIPI]exit IMX134MIPIGain2Reg function\n");
		return IMX134MIPI_sensorGainMapping[iI-1][1];
		//return NONE;
	}


/*************************************************************************
* FUNCTION
*	set_gain
*
* DESCRIPTION
*	This function is to set global gain to sensor.
*
* PARAMETERS
*	iGain : sensor global gain(base: 0x40)
*
* RETURNS
*	the actually gain set to sensor.
*
* GLOBALS AFFECTED
*
*************************************************************************/
static kal_uint16 set_gain(kal_uint16 gain)
{
	kal_uint8 iReg;
    iReg = gain2reg(gain);
	write_cmos_sensor(0x0104, 1);
    write_cmos_sensor(0x0205, (kal_uint8)iReg);
    write_cmos_sensor(0x0104, 0);

    return iReg;
}   /* IMX134MIPI_SetGain  */

static void ihdr_write_shutter_gain(kal_uint16 le, kal_uint16 se, kal_uint16 gain)
{
	LOG_INF("le:0x%x, se:0x%x, gain:0x%x\n",le,se,gain);

}



static void set_mirror_flip(kal_uint8 image_mirror)
{
	LOG_INF("image_mirror = %d\n", image_mirror);

	/********************************************************
	   *
	   *   0x3820[2] ISP Vertical flip
	   *   0x3820[1] Sensor Vertical flip
	   *
	   *   0x3821[2] ISP Horizontal mirror
	   *   0x3821[1] Sensor Horizontal mirror
	   *
	   *   ISP and Sensor flip or mirror register bit should be the same!!
	   *
	   ********************************************************/
	
    kal_uint8  iTemp; 
    iTemp = read_cmos_sensor(0x0101) & 0x03;	//Clear the mirror and flip bits.
	switch (image_mirror)
    {
        case IMAGE_NORMAL:
            write_cmos_sensor(0x0101, 0x03);	//Set normal
            break;
        case IMAGE_V_MIRROR:
            write_cmos_sensor(0x0101, iTemp | 0x01);	//Set flip
            break;
        case IMAGE_H_MIRROR:
            write_cmos_sensor(0x0101, iTemp | 0x02);	//Set mirror
            break;
        case IMAGE_HV_MIRROR:
            write_cmos_sensor(0x0101, 0x00);	//Set mirror and flip
            break;
    }

}

/*************************************************************************
* FUNCTION
*	night_mode
*
* DESCRIPTION
*	This function night mode of sensor.
*
* PARAMETERS
*	bEnable: KAL_TRUE -> enable night mode, otherwise, disable night mode
*
* RETURNS
*	None
*
* GLOBALS AFFECTED
*
*************************************************************************/
static void night_mode(kal_bool enable)
{
/*No Need to implement this function*/ 
}	/*	night_mode	*/

static void sensor_init(void)
		{
                /*[Vince] S 180 rotation*/
                #if 0
		    write_cmos_sensor(0x0101, 0x00);
                #else
		    write_cmos_sensor(0x0101, 0x03);
                #endif
                /*[Vince] E 180 rotation*/
		write_cmos_sensor(0x0105, 0x01);
		write_cmos_sensor(0x0110, 0x00);
		write_cmos_sensor(0x0220, 0x01);
		write_cmos_sensor(0x3302, 0x11);
		write_cmos_sensor(0x3833, 0x20);
		write_cmos_sensor(0x3893, 0x00);
		write_cmos_sensor(0x3906, 0x08);
		write_cmos_sensor(0x3907, 0x01);
		write_cmos_sensor(0x391B, 0x01);
		write_cmos_sensor(0x3C09, 0x01);
		write_cmos_sensor(0x600A, 0x00);
		write_cmos_sensor(0x3008, 0xB0);
		write_cmos_sensor(0x320A, 0x01);
		write_cmos_sensor(0x320D, 0x10);
		write_cmos_sensor(0x3216, 0x2E);
		write_cmos_sensor(0x322C, 0x02);
		write_cmos_sensor(0x3409, 0x0C);
		write_cmos_sensor(0x340C, 0x2D);
		write_cmos_sensor(0x3411, 0x39);
		write_cmos_sensor(0x3414, 0x1E);
		write_cmos_sensor(0x3427, 0x04);
		write_cmos_sensor(0x3480, 0x1E);
		write_cmos_sensor(0x3484, 0x1E);
		write_cmos_sensor(0x3488, 0x1E);
		write_cmos_sensor(0x348C, 0x1E);
		write_cmos_sensor(0x3490, 0x1E);
		write_cmos_sensor(0x3494, 0x1E);
		write_cmos_sensor(0x3511, 0x8F);
		write_cmos_sensor(0x3617, 0x2D);

		//Defect Correction Recommended Setting		
		//write_cmos_sensor(0x380A,0x00);    
		//write_cmos_sensor(0x380B,0x00);    
		//write_cmos_sensor(0x4103,0x00);    
		//Color Artifact Recommended Setting			
		//write_cmos_sensor(0x4243,0x9A);    
		//write_cmos_sensor(0x4330,0x01);    
		//write_cmos_sensor(0x4331,0x90);    
		//write_cmos_sensor(0x4332,0x02);    
		//write_cmos_sensor(0x4333,0x58);    
		write_cmos_sensor(0x4334,0x03);
		write_cmos_sensor(0x4335,0x20);
		write_cmos_sensor(0x4336,0x03);
		write_cmos_sensor(0x4337,0x84);
		//write_cmos_sensor(0x433C,0x01);    
		//write_cmos_sensor(0x4340,0x02);    
		//write_cmos_sensor(0x4341,0x58);    
		//write_cmos_sensor(0x4342,0x03);    
		//write_cmos_sensor(0x4343,0x52);    
		//Moir¨¦ reduction Parameter Setting			
		write_cmos_sensor(0x4364,0x0B);
		//write_cmos_sensor(0x4368,0x00);    
		//write_cmos_sensor(0x4369,0x0F);    
		//write_cmos_sensor(0x436A,0x03);    
		//write_cmos_sensor(0x436B,0xA8);    
		//write_cmos_sensor(0x436C,0x00);    
		write_cmos_sensor(0x436D,0x00);
		//write_cmos_sensor(0x436E,0x00);    
		write_cmos_sensor(0x436F,0x06);
		//CNR parameter setting			              
		write_cmos_sensor(0x4281,0x21);
		//write_cmos_sensor(0x4282,0x18);    
		write_cmos_sensor(0x4283,0x04);
		write_cmos_sensor(0x4284,0x08);
		write_cmos_sensor(0x4287,0x7F);
		write_cmos_sensor(0x4288,0x08);
		write_cmos_sensor(0x428B,0x7F);
		write_cmos_sensor(0x428C,0x08);
		write_cmos_sensor(0x428F,0x7F);
		write_cmos_sensor(0x4297,0x00);
		write_cmos_sensor(0x4298,0x7E);
		write_cmos_sensor(0x4299,0x7E);
		write_cmos_sensor(0x429A,0x7E);
		write_cmos_sensor(0x42A4,0xFB);
		write_cmos_sensor(0x42A5,0x7E);
		write_cmos_sensor(0x42A6,0xDF);
		write_cmos_sensor(0x42A7,0xB7);
		write_cmos_sensor(0x42AF,0x03);
		//ARNR Parameter Setting			            
		write_cmos_sensor(0x4207,0x03);
		write_cmos_sensor(0x4216,0x08);
		write_cmos_sensor(0x4217,0x08);
		//DLC Parameter Setting			              
		//write_cmos_sensor(0x4218,0x00);    
		write_cmos_sensor(0x421B,0x20);
		//write_cmos_sensor(0x421F,0x04);    
		//write_cmos_sensor(0x4222,0x02);    
		//write_cmos_sensor(0x4223,0x22);    
		write_cmos_sensor(0x422E,0x54);
		//write_cmos_sensor(0x422F,0xFB);    
		write_cmos_sensor(0x4230,0xFF);
		write_cmos_sensor(0x4231,0xFE);
		write_cmos_sensor(0x4232,0xFF);
		write_cmos_sensor(0x4235,0x58);
		write_cmos_sensor(0x4236,0xF7);
		write_cmos_sensor(0x4237,0xFD);
		write_cmos_sensor(0x4239,0x4E);
		write_cmos_sensor(0x423A,0xFC);
		write_cmos_sensor(0x423B,0xFD);
		//HDR Setting			                        
		write_cmos_sensor(0x4300,0x00);
		write_cmos_sensor(0x4316,0x12);
		write_cmos_sensor(0x4317,0x22);
		//write_cmos_sensor(0x4318,0x00);   
		//write_cmos_sensor(0x4319,0x00);   
		write_cmos_sensor(0x431A,0x00);
		//write_cmos_sensor(0x4324,0x03);   
		//write_cmos_sensor(0x4325,0x20);   
		//write_cmos_sensor(0x4326,0x03);   
		//write_cmos_sensor(0x4327,0x84);   
		//write_cmos_sensor(0x4328,0x03);   
		//write_cmos_sensor(0x4329,0x20);   
		//write_cmos_sensor(0x432A,0x03);   
		write_cmos_sensor(0x432B,0x20);
		//write_cmos_sensor(0x432C,0x01);   
		write_cmos_sensor(0x432D,0x01);
		//write_cmos_sensor(0x4338,0x02);   
		//write_cmos_sensor(0x4339,0x00);   
		//write_cmos_sensor(0x433A,0x00);   
		//write_cmos_sensor(0x433B,0x02);   
		//write_cmos_sensor(0x435A,0x03);   
		//write_cmos_sensor(0x435B,0x84);   
		write_cmos_sensor(0x435E,0x01);
		write_cmos_sensor(0x435F,0xFF);
		//write_cmos_sensor(0x4360,0x01);    
		//write_cmos_sensor(0x4361,0xF4);    
		//write_cmos_sensor(0x4362,0x03);    
		//write_cmos_sensor(0x4363,0x84);    
		//write_cmos_sensor(0x437B,0x01);    
		write_cmos_sensor(0x4401,0x3F);
		//write_cmos_sensor(0x4402,0xFF);    
		//write_cmos_sensor(0x4404,0x13);    
		//write_cmos_sensor(0x4405,0x26);    
		//write_cmos_sensor(0x4406,0x07);    
		//write_cmos_sensor(0x4408,0x20);    
		//write_cmos_sensor(0x4409,0xE5);    
		//write_cmos_sensor(0x440A,0xFB);    
		//write_cmos_sensor(0x440C,0xF6);    
		//write_cmos_sensor(0x440D,0xEA);    
		//write_cmos_sensor(0x440E,0x20);    
		//write_cmos_sensor(0x4410,0x00);    
		//write_cmos_sensor(0x4411,0x00);    
		write_cmos_sensor(0x4412,0x3F);
		write_cmos_sensor(0x4413,0xFF);
		//write_cmos_sensor(0x4414,0x1F);    
		//write_cmos_sensor(0x4415,0xFF);    
		//write_cmos_sensor(0x4416,0x20);    
		//write_cmos_sensor(0x4417,0x00);    
		//write_cmos_sensor(0x4418,0x1F);    
		//write_cmos_sensor(0x4419,0xFF);    
		//write_cmos_sensor(0x441A,0x20);    
		//write_cmos_sensor(0x441B,0x00);    
		write_cmos_sensor(0x441D,0x40);
		write_cmos_sensor(0x441E,0x1E);
		write_cmos_sensor(0x441F,0x38);
		//write_cmos_sensor(0x4420,0x01);    
		//write_cmos_sensor(0x4444,0x00);    
		//write_cmos_sensor(0x4445,0x00);    
		write_cmos_sensor(0x4446,0x1D);
		write_cmos_sensor(0x4447,0xF9);
		write_cmos_sensor(0x4452,0x00);
		write_cmos_sensor(0x4453,0xA0);
		write_cmos_sensor(0x4454,0x08);
		write_cmos_sensor(0x4455,0x00);
		//write_cmos_sensor(0x4456,0x0F);    
		//write_cmos_sensor(0x4457,0xFF);    
		write_cmos_sensor(0x4458,0x18);
		write_cmos_sensor(0x4459,0x18);
		write_cmos_sensor(0x445A,0x3F);
		write_cmos_sensor(0x445B,0x3A);
		//write_cmos_sensor(0x445C,0x00);    
		write_cmos_sensor(0x445D,0x28);
		//write_cmos_sensor(0x445E,0x01);    
		write_cmos_sensor(0x445F,0x90);
		//write_cmos_sensor(0x4460,0x00);    
		//write_cmos_sensor(0x4461,0x60);    
		//write_cmos_sensor(0x4462,0x00);    
		write_cmos_sensor(0x4463,0x00);
		//write_cmos_sensor(0x4464,0x00);    
		write_cmos_sensor(0x4465,0x00);
		//write_cmos_sensor(0x446C,0x00);    
		//write_cmos_sensor(0x446D,0x00);    
		//write_cmos_sensor(0x446E,0x00);    
		//LSC Setting			                        
		write_cmos_sensor(0x452A,0x02);
		//White Balance Setting			              
		//write_cmos_sensor(0x0712,0x01);    
		//write_cmos_sensor(0x0713,0x00);    
		//write_cmos_sensor(0x0714,0x01);    
		//write_cmos_sensor(0x0715,0x00);    
		//write_cmos_sensor(0x0716,0x01);    
		//write_cmos_sensor(0x0717,0x00);    
		//write_cmos_sensor(0x0718,0x01);    
		//write_cmos_sensor(0x0719,0x00);    
		//Shading setting			                    
		//write_cmos_sensor(0x4500,0x1F);    

		}   /*  gainMIPI_Sensor_Init  */


static void preview_setting(void)
		{
			write_cmos_sensor(0x0104, 0x01);//group
			write_cmos_sensor(0x0100, 0x00);//STREAM OFF 	
			//write_cmos_sensor(0x0103, 0x01);//SW reset


			//Clock Setting		                                                               //24fps               //29fps               //dummy pixel 360 binning        //232M pixel     //232               
		write_cmos_sensor(0x011E,0x18 );          //0x011E	0x18              //0x011E	0x18         0x011E	0x18             0x011E	0x18                     0x011E	0x18      0x011E	0x18 
		write_cmos_sensor(0x011F,0x00 );          //0x011F	0x00                0x011F	0x00         0x011F	0x00             0x011F	0x00                     0x011F	0x00      0x011F	0x00 
			write_cmos_sensor(0x0301,0x0A);
		write_cmos_sensor(0x0303,0x01 );          //0x0303	0x01                0x0303	0x01         0x0303	0x01             0x0303	0x01                     0x0303	0x01      0x0303	0x01 
		write_cmos_sensor(0x0305,0x0C );          //0x0305	0x0C                0x0305	0x0C         0x0305	0x0C             0x0305	0x0C                     0x0305	0x0C      0x0305	0x0C 
			write_cmos_sensor(0x0309,0x0A);
		write_cmos_sensor(0x030B,0x01 );          //0x030B	0x01                0x030B	0x01         0x030B	0x01             0x030B	0x01                     0x030B	0x01      0x030B	0x01 
		write_cmos_sensor(0x030C,0x01 );          //0x030C	0x01                0x030C	0x01         0x030C	0x01             0x030C	0x00                     0x030C	0x01      0x030C	0x01 
			write_cmos_sensor(0x030D,0xF3);
		write_cmos_sensor(0x030E,0x01 );          //0x030E	0x01                0x030E	0x01         0x030E	0x01             0x030E	0x01                     0x030E	0x01      0x030E	0x01 
		write_cmos_sensor(0x3A06,0x11 );          //0x3A06	0x11                0x3A06	0x11         0x3A06	0x11             0x3A06	0x11                     0x3A06	0x11      0x3A06	0x11 
		//Mode setting		                                   //                            	                   	                       	                               	                	           
			write_cmos_sensor(0x0108,0x01);
		write_cmos_sensor(0x0112,0x0A );          //0x0112	0x0A                0x0112	0x0A         0x0112	0x0A             0x0112	0x0A                     0x0112	0x0A      0x0112	0x0A 
		write_cmos_sensor(0x0113,0x0A );          //0x0113	0x0A                0x0113	0x0A         0x0113	0x0A             0x0113	0x0A                     0x0113	0x0A      0x0113	0x0A 
		write_cmos_sensor(0x0381,0x01 );          //0x0381	0x01                0x0381	0x01         0x0381	0x01             0x0381	0x01                     0x0381	0x01      0x0381	0x01 
		write_cmos_sensor(0x0383,0x01 );          //0x0383	0x01                0x0383	0x01         0x0383	0x01             0x0383	0x01                     0x0383	0x01      0x0383	0x01 
		write_cmos_sensor(0x0385,0x01 );          //0x0385	0x01                0x0385	0x01         0x0385	0x01             0x0385	0x01                     0x0385	0x01      0x0385	0x01 
		write_cmos_sensor(0x0387,0x01 );          //0x0387	0x01                0x0387	0x01         0x0387	0x01             0x0387	0x01                     0x0387	0x01      0x0387	0x01 
		write_cmos_sensor(0x0390,0x01 );          //0x0390	0x00                0x0390	0x01         0x0390	0x01             0x0390	0x01                     0x0390	0x01      0x0390	0x01 
		write_cmos_sensor(0x0391,0x22 );          //0x0391	0x11                0x0391	0x22         0x0391	0x22             0x0391	0x22                     0x0391	0x22      0x0391	0x22 
		write_cmos_sensor(0x0392,0x00 );          //0x0392	0x00                0x0392	0x00         0x0392	0x00             0x0392	0x00                     0x0392	0x00      0x0392	0x00 
		write_cmos_sensor(0x0401,0x00 );          //0x0401	0x02                0x0401	0x00         0x0401	0x00             0x0401	0x00                     0x0401	0x00      0x0401	0x00 
		write_cmos_sensor(0x0404,0x00 );          //0x0404	0x00                0x0404	0x00         0x0404	0x00             0x0404	0x00                     0x0404	0x00      0x0404	0x00 
		write_cmos_sensor(0x0405,0x10 );          //0x0405	0x20                0x0405	0x10         0x0405	0x10             0x0405	0x10                     0x0405	0x10      0x0405	0x10 
		write_cmos_sensor(0x4082,0x01 );          //0x4082	0x00                0x4082	0x01         0x4082	0x01             0x4082	0x01                     0x4082	0x01      0x4082	0x01 
		write_cmos_sensor(0x4083,0x01 );          //0x4083	0x00                0x4083	0x01         0x4083	0x01             0x4083	0x01                     0x4083	0x01      0x4083	0x01 
		write_cmos_sensor(0x7006,0x04 );          //0x7006	0x04                0x7006	0x04         0x7006	0x04             0x7006	0x04                     0x7006	0x04      0x7006	0x04 
		//OptionnalFunction setting		                       //                            	                   	                       	                               	                	           
		write_cmos_sensor(0x0700,0x00 );          //0x0700	0x00                0x0700	0x00         0x0700	0x00             0x0700	0x00                     0x0700	0x00      0x0700	0x00 
		write_cmos_sensor(0x3A63,0x00 );          //0x3A63	0x00                0x3A63	0x00         0x3A63	0x00             0x3A63	0x00                     0x3A63	0x00      0x3A63	0x00 
		write_cmos_sensor(0x4100,0xF8 );          //0x4100	0xF8                0x4100	0xF8         0x4100	0xF8             0x4100	0xF8                     0x4100	0xF8      0x4100	0xF8 
		write_cmos_sensor(0x4203,0xFF );          //0x4203	0xFF                0x4203	0xFF         0x4203	0xFF             0x4203	0xFF                     0x4203	0xFF      0x4203	0xFF 
		write_cmos_sensor(0x4344,0x00 );          //0x4344	0x00                0x4344	0x00         0x4344	0x00             0x4344	0x00                     0x4344	0x00      0x4344	0x00 
		write_cmos_sensor(0x441C,0x01 );          //0x441C	0x01                0x441C	0x01         0x441C	0x01             0x441C	0x01                     0x441C	0x01      0x441C	0x01 
		//Size setting		                                   //                            	                   	                       	                               	                	           
		write_cmos_sensor(0x0340,0x07 );          //0x0340	0x08                0x0340	0x0A         0x0340	0x09             0x0340	0x06                     0x0340	0x07      0x0340	0x07 
			write_cmos_sensor(0x0341,0x38);
			write_cmos_sensor(0x0342,0x0E);
			write_cmos_sensor(0x0343,0x10);
		write_cmos_sensor(0x0344,0x00 );          //0x0344	0x00                0x0344	0x00         0x0344	0x00             0x0344	0x00                     0x0344	0x00      0x0344	0x00 
		write_cmos_sensor(0x0345,0x00 );          //0x0345	0x00                0x0345	0x08         0x0345	0x08             0x0345	0x00                     0x0345	0x00      0x0345	0x00 
		write_cmos_sensor(0x0346,0x00 );          //0x0346	0x00                0x0346	0x00         0x0346	0x00             0x0346	0x00                     0x0346	0x00      0x0346	0x00 
		write_cmos_sensor(0x0347,0x00 );          //0x0347	0x00                0x0347	0x08         0x0347	0x14             0x0347	0x00                     0x0347	0x00      0x0347	0x00 
		write_cmos_sensor(0x0348,0x0C );          //0x0348	0x0C                0x0348	0x0C         0x0348	0x0C             0x0348	0x0C                     0x0348	0x0C      0x0348	0x0C 
		write_cmos_sensor(0x0349,0xCF );          //0x0349	0xCF                0x0349	0xC7         0x0349	0xC7             0x0349	0xCF                     0x0349	0xCF      0x0349	0xCF 
		write_cmos_sensor(0x034A,0x09 );          //0x034A	0x09                0x034A	0x09         0x034A	0x09             0x034A	0x09                     0x034A	0x09      0x034A	0x09 
		write_cmos_sensor(0x034B,0x9F );          //0x034B	0x9F                0x034B	0x97         0x034B	0x8B             0x034B	0x9F                     0x034B	0x9F      0x034B	0x9F 
		write_cmos_sensor(0x034C,0x06 );          //0x034C	0x06                0x034C	0x06         0x034C	0x06             0x034C	0x06                     0x034C	0x06      0x034C	0x06 
		write_cmos_sensor(0x034D,0x68 );          //0x034D	0x68                0x034D	0x60         0x034D	0x60             0x034D	0x68                     0x034D	0x68      0x034D	0x68 
		write_cmos_sensor(0x034E,0x04 );          //0x034E	0x04                0x034E	0x04         0x034E	0x04             0x034E	0x04                     0x034E	0x04      0x034E	0x04 
		write_cmos_sensor(0x034F,0xD0 );          //0x034F	0xD0                0x034F	0xC8         0x034F	0xBC             0x034F	0xD0                     0x034F	0xD0      0x034F	0xD0 
		write_cmos_sensor(0x0350,0x00 );          //0x0350	0x00                0x0350	0x00         0x0350	0x00             0x0350	0x00                     0x0350	0x00      0x0350	0x00 
		write_cmos_sensor(0x0351,0x00 );          //0x0351	0x00                0x0351	0x00         0x0351	0x00             0x0351	0x00                     0x0351	0x00      0x0351	0x00 
		write_cmos_sensor(0x0352,0x00 );          //0x0352	0x00                0x0352	0x00         0x0352	0x00             0x0352	0x00                     0x0352	0x00      0x0352	0x00 
		write_cmos_sensor(0x0353,0x00 );          //0x0353	0x00                0x0353	0x00         0x0353	0x00             0x0353	0x00                     0x0353	0x00      0x0353	0x00 
		write_cmos_sensor(0x0354,0x06 );          //0x0354	0x0C                0x0354	0x06         0x0354	0x06             0x0354	0x06                     0x0354	0x06      0x0354	0x06 
		write_cmos_sensor(0x0355,0x68 );          //0x0355	0xD0                0x0355	0x60         0x0355	0x60             0x0355	0x68                     0x0355	0x68      0x0355	0x68 
		write_cmos_sensor(0x0356,0x04 );          //0x0356	0x09                0x0356	0x04         0x0356	0x04             0x0356	0x04                     0x0356	0x04      0x0356	0x04 
		write_cmos_sensor(0x0357,0xD0 );          //0x0357	0xA0                0x0357	0xC8         0x0357	0xBC             0x0357	0xD0                     0x0357	0xD0      0x0357	0xD0 
		write_cmos_sensor(0x301D,0x30 );          //0x301D	0x30                0x301D	0x30         0x301D	0x30             0x301D	0x30                     0x301D	0x30      0x301D	0x30 
		write_cmos_sensor(0x3310,0x06 );          //0x3310	0x06                0x3310	0x06         0x3310	0x06             0x3310	0x06                     0x3310	0x06      0x3310	0x06 
		write_cmos_sensor(0x3311,0x68 );          //0x3311	0x68                0x3311	0x60         0x3311	0x60             0x3311	0x68                     0x3311	0x68      0x3311	0x68 
		write_cmos_sensor(0x3312,0x04 );          //0x3312	0x04                0x3312	0x04         0x3312	0x04             0x3312	0x04                     0x3312	0x04      0x3312	0x04 
		write_cmos_sensor(0x3313,0xD0 );          //0x3313	0xD0                0x3313	0xC8         0x3313	0xBC             0x3313	0xD0                     0x3313	0xD0      0x3313	0xD0 
		write_cmos_sensor(0x331C,0x04 );          //0x331C	0x04                0x331C	0x04         0x331C	0x04             0x331C	0x04                     0x331C	0x04      0x331C	0x04 
		write_cmos_sensor(0x331D,0x06 );          //0x331D	0x1E                0x331D	0x06         0x331D	0x06             0x331D	0x06                     0x331D	0x06      0x331D	0x06 
		write_cmos_sensor(0x4084,0x00 );          //0x4084	0x06                0x4084	0x00         0x4084	0x00             0x4084	0x00                     0x4084	0x00      0x4084	0x00 
		write_cmos_sensor(0x4085,0x00 );          //0x4085	0x68                0x4085	0x00         0x4085	0x00             0x4085	0x00                     0x4085	0x00      0x4085	0x00 
		write_cmos_sensor(0x4086,0x00 );          //0x4086	0x04                0x4086	0x00         0x4086	0x00             0x4086	0x00                     0x4086	0x00      0x4086	0x00 
		write_cmos_sensor(0x4087,0x00 );          //0x4087	0xD0                0x4087	0x00         0x4087	0x00             0x4087	0x00                     0x4087	0x00      0x4087	0x00 
		write_cmos_sensor(0x4400,0x00 );          //0x4400	0x00                0x4400	0x00         0x4400	0x00             0x4400	0x00                     0x4400	0x00      0x4400	0x00 
		//Global Timing Setting		                           //	                          	                   	                       	                               	                	           
			write_cmos_sensor(0x0830,0x87);
			write_cmos_sensor(0x0831,0x3F);
			write_cmos_sensor(0x0832,0x77);
			write_cmos_sensor(0x0833,0x47);
			write_cmos_sensor(0x0834,0x47);
			write_cmos_sensor(0x0835,0x57);
			write_cmos_sensor(0x0836,0xF7);
			write_cmos_sensor(0x0837,0x4F);
		write_cmos_sensor(0x0839,0x1F );          //0x0839	0x1F                0x0839	0x1F         0x0839	0x1F             0x0839	0x1F                     0x0839	0x1F      0x0839	0x1F 
		write_cmos_sensor(0x083A,0x17 );          //0x083A	0x17                0x083A	0x17         0x083A	0x17             0x083A	0x17                     0x083A	0x17      0x083A	0x17 
		write_cmos_sensor(0x083B,0x02 );          //0x083B	0x02                0x083B	0x02         0x083B	0x02             0x083B	0x02                     0x083B	0x02      0x083B	0x02 
		//Integration Time Setting		                       //	                          	                   	                       	                               	                	           
		write_cmos_sensor(0x0202,0x07 );          //0x0202	0x08                0x0202	0x0A         0x0202	0x09             0x0202	0x06                     0x0202	0x07      0x0202	0x07 
			write_cmos_sensor(0x0203,0x34);
		//Gain Setting		                                   //	                          	                   	                       	                               	                	           
		write_cmos_sensor(0x0205,0x00 );          //0x0205	0x00                0x0205	0x00         0x0205	0x00             0x0205	0x00                     0x0205	0x00      0x0205	0x00 
		write_cmos_sensor(0x020E,0x01 );          //0x020E	0x01                0x020E	0x01         0x020E	0x01             0x020E	0x01                     0x020E	0x01      0x020E	0x01 
		write_cmos_sensor(0x020F,0x00 );          //0x020F	0x00                0x020F	0x00         0x020F	0x00             0x020F	0x00                     0x020F	0x00      0x020F	0x00 
		write_cmos_sensor(0x0210,0x01 );          //0x0210	0x01                0x0210	0x01         0x0210	0x01             0x0210	0x01                     0x0210	0x01      0x0210	0x01 
		write_cmos_sensor(0x0211,0x00 );          //0x0211	0x00                0x0211	0x00         0x0211	0x00             0x0211	0x00                     0x0211	0x00      0x0211	0x00 
		write_cmos_sensor(0x0212,0x01 );          //0x0212	0x01                0x0212	0x01         0x0212	0x01             0x0212	0x01                     0x0212	0x01      0x0212	0x01 
		write_cmos_sensor(0x0213,0x00 );          //0x0213	0x00                0x0213	0x00         0x0213	0x00             0x0213	0x00                     0x0213	0x00      0x0213	0x00 
		write_cmos_sensor(0x0214,0x01 );          //0x0214	0x01                0x0214	0x01         0x0214	0x01             0x0214	0x01                     0x0214	0x01      0x0214	0x01 
		write_cmos_sensor(0x0215,0x00 );          //0x0215	0x00                0x0215	0x00         0x0215	0x00             0x0215	0x00                     0x0215	0x00      0x0215	0x00 
		//HDR Setting		                                     //                            	                   	                       	                               	                	           
		write_cmos_sensor(0x0230,0x00 );          //0x0230	0x00                0x0230	0x00         0x0230	0x00             0x0230	0x00                     0x0230	0x00      0x0230	0x00 
		write_cmos_sensor(0x0231,0x00 );          //0x0231	0x00                0x0231	0x00         0x0231	0x00             0x0231	0x00                     0x0231	0x00      0x0231	0x00 
		write_cmos_sensor(0x0233,0x00 );          //0x0233	0x00                0x0233	0x00         0x0233	0x00             0x0233	0x00                     0x0233	0x00      0x0233	0x00 
		write_cmos_sensor(0x0234,0x00 );          //0x0234	0x00                0x0234	0x00         0x0234	0x00             0x0234	0x00                     0x0234	0x00      0x0234	0x00 
		write_cmos_sensor(0x0235,0x40 );          //0x0235	0x40                0x0235	0x40         0x0235	0x40             0x0235	0x40                     0x0235	0x40      0x0235	0x40 
		write_cmos_sensor(0x0238,0x00 );          //0x0238	0x00                0x0238	0x00         0x0238	0x00             0x0238	0x00                     0x0238	0x00      0x0238	0x00 
		write_cmos_sensor(0x0239,0x04 );          //0x0239	0x04                0x0239	0x04         0x0239	0x04             0x0239	0x04                     0x0239	0x04      0x0239	0x04 
		write_cmos_sensor(0x023B,0x00 );          //0x023B	0x00                0x023B	0x00         0x023B	0x00             0x023B	0x00                     0x023B	0x00      0x023B	0x00 
		write_cmos_sensor(0x023C,0x01 );          //0x023C	0x01                0x023C	0x01         0x023C	0x01             0x023C	0x01                     0x023C	0x01      0x023C	0x01 
		write_cmos_sensor(0x33B0,0x04 );          //0x33B0	0x04                0x33B0	0x04         0x33B0	0x04             0x33B0	0x04                     0x33B0	0x04      0x33B0	0x04 
		write_cmos_sensor(0x33B1,0x00 );          //0x33B1	0x00                0x33B1	0x00         0x33B1	0x00             0x33B1	0x00                     0x33B1	0x00      0x33B1	0x00 
		write_cmos_sensor(0x33B3,0x00 );          //0x33B3	0x00                0x33B3	0x00         0x33B3	0x00             0x33B3	0x00                     0x33B3	0x00      0x33B3	0x00 
		write_cmos_sensor(0x33B4,0x01 );          //0x33B4	0x01                0x33B4	0x01         0x33B4	0x01             0x33B4	0x01                     0x33B4	0x01      0x33B4	0x01 
		write_cmos_sensor(0x3800,0x00 );          //0x3800	0x00                0x3800	0x00         0x3800	0x00             0x3800	0x00                     0x3800	0x00      0x3800	0x00 



			write_cmos_sensor(0x0104, 0x00);//group
			write_cmos_sensor(0x0100, 0x01);//STREAM ON
			// The register only need to enable 1 time.    
		}   /*  gainMIPI_Capture_Setting  */

static void capture_setting(kal_uint16 currefps)
{
		{	//77 capture setting

	write_cmos_sensor(0x0104, 0x01);//group
	write_cmos_sensor(0x0100, 0x00);//STREAM OFF 	
	//write_cmos_sensor(0x0103, 0x01);//SW reset
	
	//Clock Setting		                        
write_cmos_sensor(0x011E,0x18);  
write_cmos_sensor(0x011F,0x00);  
	write_cmos_sensor(0x0301,0x0A);
write_cmos_sensor(0x0303,0x01);  
write_cmos_sensor(0x0305,0x0C);  
	write_cmos_sensor(0x0309,0x0A);
write_cmos_sensor(0x030B,0x01);  
write_cmos_sensor(0x030C,0x01);  
	write_cmos_sensor(0x030D,0xF3);
write_cmos_sensor(0x030E,0x01);  
write_cmos_sensor(0x3A06,0x11);  
//Mode setting		                          
	write_cmos_sensor(0x0108,0x01);
write_cmos_sensor(0x0112,0x0A);  
write_cmos_sensor(0x0113,0x0A);  
write_cmos_sensor(0x0381,0x01);  
write_cmos_sensor(0x0383,0x01);  
write_cmos_sensor(0x0385,0x01);  
write_cmos_sensor(0x0387,0x01);  
write_cmos_sensor(0x0390,0x00);  
write_cmos_sensor(0x0391,0x11);  
write_cmos_sensor(0x0392,0x00);  
write_cmos_sensor(0x0401,0x00);  
write_cmos_sensor(0x0404,0x00);  
write_cmos_sensor(0x0405,0x10);  
write_cmos_sensor(0x4082,0x01);  
write_cmos_sensor(0x4083,0x01);  
write_cmos_sensor(0x7006,0x04);  
//OptionnalFunction setting		              
write_cmos_sensor(0x0700,0x00);  
write_cmos_sensor(0x3A63,0x00);  
write_cmos_sensor(0x4100,0xF8);  
write_cmos_sensor(0x4203,0xFF);  
write_cmos_sensor(0x4344,0x00);  
write_cmos_sensor(0x441C,0x01);  
//Size setting		                          
write_cmos_sensor(0x0340,0x09);  
	write_cmos_sensor(0x0341,0xD8);
write_cmos_sensor(0x0342,0x0E);  
write_cmos_sensor(0x0343,0x10);  
write_cmos_sensor(0x0344,0x00);  
write_cmos_sensor(0x0345,0x00);  
write_cmos_sensor(0x0346,0x00);  
write_cmos_sensor(0x0347,0x00);  
write_cmos_sensor(0x0348,0x0C);  
write_cmos_sensor(0x0349,0xCF);  
write_cmos_sensor(0x034A,0x09);  
write_cmos_sensor(0x034B,0x9F);  
write_cmos_sensor(0x034C,0x0C);  
write_cmos_sensor(0x034D,0xD0);  
write_cmos_sensor(0x034E,0x09);  
write_cmos_sensor(0x034F,0xA0);  
write_cmos_sensor(0x0350,0x00);  
write_cmos_sensor(0x0351,0x00);  
write_cmos_sensor(0x0352,0x00);  
write_cmos_sensor(0x0353,0x00);  
write_cmos_sensor(0x0354,0x0C);  
write_cmos_sensor(0x0355,0xD0);  
write_cmos_sensor(0x0356,0x09);  
write_cmos_sensor(0x0357,0xA0);  
write_cmos_sensor(0x301D,0x30);  
write_cmos_sensor(0x3310,0x0C);  
write_cmos_sensor(0x3311,0xD0);  
write_cmos_sensor(0x3312,0x09);  
write_cmos_sensor(0x3313,0xA0);  
write_cmos_sensor(0x331C,0x01);  
write_cmos_sensor(0x331D,0xAE);  
write_cmos_sensor(0x4084,0x00);  
write_cmos_sensor(0x4085,0x00);  
write_cmos_sensor(0x4086,0x00);  
write_cmos_sensor(0x4087,0x00);  
write_cmos_sensor(0x4400,0x00);  
//Global Timing Setting		                  
	write_cmos_sensor(0x0830,0x87);
	write_cmos_sensor(0x0831,0x3F);
	write_cmos_sensor(0x0832,0x77);
	write_cmos_sensor(0x0833,0x47);
	write_cmos_sensor(0x0834,0x47);
	write_cmos_sensor(0x0835,0x57);
	write_cmos_sensor(0x0836,0xF7);
	write_cmos_sensor(0x0837,0x4F);
write_cmos_sensor(0x0839,0x1F);  
write_cmos_sensor(0x083A,0x17);  
write_cmos_sensor(0x083B,0x02);  
//Integration Time Setting		              
write_cmos_sensor(0x0202,0x09);  
	write_cmos_sensor(0x0203,0xD4);
//Gain Setting		                          
write_cmos_sensor(0x0205,0x00);  
write_cmos_sensor(0x020E,0x01);  
write_cmos_sensor(0x020F,0x00);  
write_cmos_sensor(0x0210,0x01);  
write_cmos_sensor(0x0211,0x00);  
write_cmos_sensor(0x0212,0x01);  
write_cmos_sensor(0x0213,0x00);  
write_cmos_sensor(0x0214,0x01);  
write_cmos_sensor(0x0215,0x00);  
//HDR Setting		                            
write_cmos_sensor(0x0230,0x00);  
write_cmos_sensor(0x0231,0x00);  
write_cmos_sensor(0x0233,0x00);  
write_cmos_sensor(0x0234,0x00);  
write_cmos_sensor(0x0235,0x40);  
write_cmos_sensor(0x0238,0x00);  
write_cmos_sensor(0x0239,0x04);  
write_cmos_sensor(0x023B,0x00);  
write_cmos_sensor(0x023C,0x01);  
write_cmos_sensor(0x33B0,0x04);  
write_cmos_sensor(0x33B1,0x00);  
write_cmos_sensor(0x33B3,0x00);  
write_cmos_sensor(0x33B4,0x01);  
write_cmos_sensor(0x3800,0x00);  

	//Clock Setting		                                                 
//Mode setting		                                  //               
//OptionnalFunction setting		                      //               
//Size setting		                                  //               
//Global Timing Setting		                          //	             
//Integration Time Setting		                      //	             
//Gain Setting		                                  //	             
//HDR Setting		                                    //               


	
	write_cmos_sensor(0x0104, 0x00);//group
	write_cmos_sensor(0x0100, 0x01);//STREAM ON

}


}
static void normal_video_setting(kal_uint16 currefps)
	{
	write_cmos_sensor(0x0104, 0x01);//group
	write_cmos_sensor(0x0100, 0x00);//STREAM OFF 	
	//write_cmos_sensor(0x0103, 0x01);//SW reset


	//Clock Setting		                                                               //24fps               //29fps               //dummy pixel 360 binning        //232M pixel     //232               
write_cmos_sensor(0x011E,0x18 );          //0x011E	0x18              //0x011E	0x18         0x011E	0x18             0x011E	0x18                     0x011E	0x18      0x011E	0x18 
write_cmos_sensor(0x011F,0x00 );          //0x011F	0x00                0x011F	0x00         0x011F	0x00             0x011F	0x00                     0x011F	0x00      0x011F	0x00 
	write_cmos_sensor(0x0301,0x0A);
write_cmos_sensor(0x0303,0x01 );          //0x0303	0x01                0x0303	0x01         0x0303	0x01             0x0303	0x01                     0x0303	0x01      0x0303	0x01 
write_cmos_sensor(0x0305,0x0C );          //0x0305	0x0C                0x0305	0x0C         0x0305	0x0C             0x0305	0x0C                     0x0305	0x0C      0x0305	0x0C 
	write_cmos_sensor(0x0309,0x0A);
write_cmos_sensor(0x030B,0x01 );          //0x030B	0x01                0x030B	0x01         0x030B	0x01             0x030B	0x01                     0x030B	0x01      0x030B	0x01 
write_cmos_sensor(0x030C,0x01 );          //0x030C	0x01                0x030C	0x01         0x030C	0x01             0x030C	0x00                     0x030C	0x01      0x030C	0x01 
	write_cmos_sensor(0x030D,0xF3);
write_cmos_sensor(0x030E,0x01 );          //0x030E	0x01                0x030E	0x01         0x030E	0x01             0x030E	0x01                     0x030E	0x01      0x030E	0x01 
write_cmos_sensor(0x3A06,0x11 );          //0x3A06	0x11                0x3A06	0x11         0x3A06	0x11             0x3A06	0x11                     0x3A06	0x11      0x3A06	0x11 
//Mode setting		                                   //                            	                   	                       	                               	                	           
	write_cmos_sensor(0x0108,0x01);
write_cmos_sensor(0x0112,0x0A );          //0x0112	0x0A                0x0112	0x0A         0x0112	0x0A             0x0112	0x0A                     0x0112	0x0A      0x0112	0x0A 
write_cmos_sensor(0x0113,0x0A );          //0x0113	0x0A                0x0113	0x0A         0x0113	0x0A             0x0113	0x0A                     0x0113	0x0A      0x0113	0x0A 
write_cmos_sensor(0x0381,0x01 );          //0x0381	0x01                0x0381	0x01         0x0381	0x01             0x0381	0x01                     0x0381	0x01      0x0381	0x01 
write_cmos_sensor(0x0383,0x01 );          //0x0383	0x01                0x0383	0x01         0x0383	0x01             0x0383	0x01                     0x0383	0x01      0x0383	0x01 
write_cmos_sensor(0x0385,0x01 );          //0x0385	0x01                0x0385	0x01         0x0385	0x01             0x0385	0x01                     0x0385	0x01      0x0385	0x01 
write_cmos_sensor(0x0387,0x01 );          //0x0387	0x01                0x0387	0x01         0x0387	0x01             0x0387	0x01                     0x0387	0x01      0x0387	0x01 
write_cmos_sensor(0x0390,0x01 );          //0x0390	0x00                0x0390	0x01         0x0390	0x01             0x0390	0x01                     0x0390	0x01      0x0390	0x01 
write_cmos_sensor(0x0391,0x22 );          //0x0391	0x11                0x0391	0x22         0x0391	0x22             0x0391	0x22                     0x0391	0x22      0x0391	0x22 
write_cmos_sensor(0x0392,0x00 );          //0x0392	0x00                0x0392	0x00         0x0392	0x00             0x0392	0x00                     0x0392	0x00      0x0392	0x00 
write_cmos_sensor(0x0401,0x00 );          //0x0401	0x02                0x0401	0x00         0x0401	0x00             0x0401	0x00                     0x0401	0x00      0x0401	0x00 
write_cmos_sensor(0x0404,0x00 );          //0x0404	0x00                0x0404	0x00         0x0404	0x00             0x0404	0x00                     0x0404	0x00      0x0404	0x00 
write_cmos_sensor(0x0405,0x10 );          //0x0405	0x20                0x0405	0x10         0x0405	0x10             0x0405	0x10                     0x0405	0x10      0x0405	0x10 
write_cmos_sensor(0x4082,0x01 );          //0x4082	0x00                0x4082	0x01         0x4082	0x01             0x4082	0x01                     0x4082	0x01      0x4082	0x01 
write_cmos_sensor(0x4083,0x01 );          //0x4083	0x00                0x4083	0x01         0x4083	0x01             0x4083	0x01                     0x4083	0x01      0x4083	0x01 
write_cmos_sensor(0x7006,0x04 );          //0x7006	0x04                0x7006	0x04         0x7006	0x04             0x7006	0x04                     0x7006	0x04      0x7006	0x04 
//OptionnalFunction setting		                       //                            	                   	                       	                               	                	           
write_cmos_sensor(0x0700,0x00 );          //0x0700	0x00                0x0700	0x00         0x0700	0x00             0x0700	0x00                     0x0700	0x00      0x0700	0x00 
write_cmos_sensor(0x3A63,0x00 );          //0x3A63	0x00                0x3A63	0x00         0x3A63	0x00             0x3A63	0x00                     0x3A63	0x00      0x3A63	0x00 
write_cmos_sensor(0x4100,0xF8 );          //0x4100	0xF8                0x4100	0xF8         0x4100	0xF8             0x4100	0xF8                     0x4100	0xF8      0x4100	0xF8 
write_cmos_sensor(0x4203,0xFF );          //0x4203	0xFF                0x4203	0xFF         0x4203	0xFF             0x4203	0xFF                     0x4203	0xFF      0x4203	0xFF 
write_cmos_sensor(0x4344,0x00 );          //0x4344	0x00                0x4344	0x00         0x4344	0x00             0x4344	0x00                     0x4344	0x00      0x4344	0x00 
write_cmos_sensor(0x441C,0x01 );          //0x441C	0x01                0x441C	0x01         0x441C	0x01             0x441C	0x01                     0x441C	0x01      0x441C	0x01 
//Size setting		                                   //                            	                   	                       	                               	                	           
write_cmos_sensor(0x0340,0x07 );          //0x0340	0x08                0x0340	0x0A         0x0340	0x09             0x0340	0x06                     0x0340	0x07      0x0340	0x07 
	write_cmos_sensor(0x0341,0x38);
	write_cmos_sensor(0x0342,0x0E);
	write_cmos_sensor(0x0343,0x10);
write_cmos_sensor(0x0344,0x00 );          //0x0344	0x00                0x0344	0x00         0x0344	0x00             0x0344	0x00                     0x0344	0x00      0x0344	0x00 
write_cmos_sensor(0x0345,0x00 );          //0x0345	0x00                0x0345	0x08         0x0345	0x08             0x0345	0x00                     0x0345	0x00      0x0345	0x00 
write_cmos_sensor(0x0346,0x00 );          //0x0346	0x00                0x0346	0x00         0x0346	0x00             0x0346	0x00                     0x0346	0x00      0x0346	0x00 
write_cmos_sensor(0x0347,0x00 );          //0x0347	0x00                0x0347	0x08         0x0347	0x14             0x0347	0x00                     0x0347	0x00      0x0347	0x00 
write_cmos_sensor(0x0348,0x0C );          //0x0348	0x0C                0x0348	0x0C         0x0348	0x0C             0x0348	0x0C                     0x0348	0x0C      0x0348	0x0C 
write_cmos_sensor(0x0349,0xCF );          //0x0349	0xCF                0x0349	0xC7         0x0349	0xC7             0x0349	0xCF                     0x0349	0xCF      0x0349	0xCF 
write_cmos_sensor(0x034A,0x09 );          //0x034A	0x09                0x034A	0x09         0x034A	0x09             0x034A	0x09                     0x034A	0x09      0x034A	0x09 
write_cmos_sensor(0x034B,0x9F );          //0x034B	0x9F                0x034B	0x97         0x034B	0x8B             0x034B	0x9F                     0x034B	0x9F      0x034B	0x9F 
write_cmos_sensor(0x034C,0x06 );          //0x034C	0x06                0x034C	0x06         0x034C	0x06             0x034C	0x06                     0x034C	0x06      0x034C	0x06 
write_cmos_sensor(0x034D,0x68 );          //0x034D	0x68                0x034D	0x60         0x034D	0x60             0x034D	0x68                     0x034D	0x68      0x034D	0x68 
write_cmos_sensor(0x034E,0x04 );          //0x034E	0x04                0x034E	0x04         0x034E	0x04             0x034E	0x04                     0x034E	0x04      0x034E	0x04 
write_cmos_sensor(0x034F,0xD0 );          //0x034F	0xD0                0x034F	0xC8         0x034F	0xBC             0x034F	0xD0                     0x034F	0xD0      0x034F	0xD0 
write_cmos_sensor(0x0350,0x00 );          //0x0350	0x00                0x0350	0x00         0x0350	0x00             0x0350	0x00                     0x0350	0x00      0x0350	0x00 
write_cmos_sensor(0x0351,0x00 );          //0x0351	0x00                0x0351	0x00         0x0351	0x00             0x0351	0x00                     0x0351	0x00      0x0351	0x00 
write_cmos_sensor(0x0352,0x00 );          //0x0352	0x00                0x0352	0x00         0x0352	0x00             0x0352	0x00                     0x0352	0x00      0x0352	0x00 
write_cmos_sensor(0x0353,0x00 );          //0x0353	0x00                0x0353	0x00         0x0353	0x00             0x0353	0x00                     0x0353	0x00      0x0353	0x00 
write_cmos_sensor(0x0354,0x06 );          //0x0354	0x0C                0x0354	0x06         0x0354	0x06             0x0354	0x06                     0x0354	0x06      0x0354	0x06 
write_cmos_sensor(0x0355,0x68 );          //0x0355	0xD0                0x0355	0x60         0x0355	0x60             0x0355	0x68                     0x0355	0x68      0x0355	0x68 
write_cmos_sensor(0x0356,0x04 );          //0x0356	0x09                0x0356	0x04         0x0356	0x04             0x0356	0x04                     0x0356	0x04      0x0356	0x04 
write_cmos_sensor(0x0357,0xD0 );          //0x0357	0xA0                0x0357	0xC8         0x0357	0xBC             0x0357	0xD0                     0x0357	0xD0      0x0357	0xD0 
write_cmos_sensor(0x301D,0x30 );          //0x301D	0x30                0x301D	0x30         0x301D	0x30             0x301D	0x30                     0x301D	0x30      0x301D	0x30 
write_cmos_sensor(0x3310,0x06 );          //0x3310	0x06                0x3310	0x06         0x3310	0x06             0x3310	0x06                     0x3310	0x06      0x3310	0x06 
write_cmos_sensor(0x3311,0x68 );          //0x3311	0x68                0x3311	0x60         0x3311	0x60             0x3311	0x68                     0x3311	0x68      0x3311	0x68 
write_cmos_sensor(0x3312,0x04 );          //0x3312	0x04                0x3312	0x04         0x3312	0x04             0x3312	0x04                     0x3312	0x04      0x3312	0x04 
write_cmos_sensor(0x3313,0xD0 );          //0x3313	0xD0                0x3313	0xC8         0x3313	0xBC             0x3313	0xD0                     0x3313	0xD0      0x3313	0xD0 
write_cmos_sensor(0x331C,0x04 );          //0x331C	0x04                0x331C	0x04         0x331C	0x04             0x331C	0x04                     0x331C	0x04      0x331C	0x04 
write_cmos_sensor(0x331D,0x06 );          //0x331D	0x1E                0x331D	0x06         0x331D	0x06             0x331D	0x06                     0x331D	0x06      0x331D	0x06 
write_cmos_sensor(0x4084,0x00 );          //0x4084	0x06                0x4084	0x00         0x4084	0x00             0x4084	0x00                     0x4084	0x00      0x4084	0x00 
write_cmos_sensor(0x4085,0x00 );          //0x4085	0x68                0x4085	0x00         0x4085	0x00             0x4085	0x00                     0x4085	0x00      0x4085	0x00 
write_cmos_sensor(0x4086,0x00 );          //0x4086	0x04                0x4086	0x00         0x4086	0x00             0x4086	0x00                     0x4086	0x00      0x4086	0x00 
write_cmos_sensor(0x4087,0x00 );          //0x4087	0xD0                0x4087	0x00         0x4087	0x00             0x4087	0x00                     0x4087	0x00      0x4087	0x00 
write_cmos_sensor(0x4400,0x00 );          //0x4400	0x00                0x4400	0x00         0x4400	0x00             0x4400	0x00                     0x4400	0x00      0x4400	0x00 
//Global Timing Setting		                           //	                          	                   	                       	                               	                	           
	write_cmos_sensor(0x0830,0x87);
	write_cmos_sensor(0x0831,0x3F);
	write_cmos_sensor(0x0832,0x77);
	write_cmos_sensor(0x0833,0x47);
	write_cmos_sensor(0x0834,0x47);
	write_cmos_sensor(0x0835,0x57);
	write_cmos_sensor(0x0836,0xF7);
	write_cmos_sensor(0x0837,0x4F);
write_cmos_sensor(0x0839,0x1F );          //0x0839	0x1F                0x0839	0x1F         0x0839	0x1F             0x0839	0x1F                     0x0839	0x1F      0x0839	0x1F 
write_cmos_sensor(0x083A,0x17 );          //0x083A	0x17                0x083A	0x17         0x083A	0x17             0x083A	0x17                     0x083A	0x17      0x083A	0x17 
write_cmos_sensor(0x083B,0x02 );          //0x083B	0x02                0x083B	0x02         0x083B	0x02             0x083B	0x02                     0x083B	0x02      0x083B	0x02 
//Integration Time Setting		                       //	                          	                   	                       	                               	                	           
write_cmos_sensor(0x0202,0x07 );          //0x0202	0x08                0x0202	0x0A         0x0202	0x09             0x0202	0x06                     0x0202	0x07      0x0202	0x07 
	write_cmos_sensor(0x0203,0x34);
//Gain Setting		                                   //	                          	                   	                       	                               	                	           
write_cmos_sensor(0x0205,0x00 );          //0x0205	0x00                0x0205	0x00         0x0205	0x00             0x0205	0x00                     0x0205	0x00      0x0205	0x00 
write_cmos_sensor(0x020E,0x01 );          //0x020E	0x01                0x020E	0x01         0x020E	0x01             0x020E	0x01                     0x020E	0x01      0x020E	0x01 
write_cmos_sensor(0x020F,0x00 );          //0x020F	0x00                0x020F	0x00         0x020F	0x00             0x020F	0x00                     0x020F	0x00      0x020F	0x00 
write_cmos_sensor(0x0210,0x01 );          //0x0210	0x01                0x0210	0x01         0x0210	0x01             0x0210	0x01                     0x0210	0x01      0x0210	0x01 
write_cmos_sensor(0x0211,0x00 );          //0x0211	0x00                0x0211	0x00         0x0211	0x00             0x0211	0x00                     0x0211	0x00      0x0211	0x00 
write_cmos_sensor(0x0212,0x01 );          //0x0212	0x01                0x0212	0x01         0x0212	0x01             0x0212	0x01                     0x0212	0x01      0x0212	0x01 
write_cmos_sensor(0x0213,0x00 );          //0x0213	0x00                0x0213	0x00         0x0213	0x00             0x0213	0x00                     0x0213	0x00      0x0213	0x00 
write_cmos_sensor(0x0214,0x01 );          //0x0214	0x01                0x0214	0x01         0x0214	0x01             0x0214	0x01                     0x0214	0x01      0x0214	0x01 
write_cmos_sensor(0x0215,0x00 );          //0x0215	0x00                0x0215	0x00         0x0215	0x00             0x0215	0x00                     0x0215	0x00      0x0215	0x00 
//HDR Setting		                                     //                            	                   	                       	                               	                	           
write_cmos_sensor(0x0230,0x00 );          //0x0230	0x00                0x0230	0x00         0x0230	0x00             0x0230	0x00                     0x0230	0x00      0x0230	0x00 
write_cmos_sensor(0x0231,0x00 );          //0x0231	0x00                0x0231	0x00         0x0231	0x00             0x0231	0x00                     0x0231	0x00      0x0231	0x00 
write_cmos_sensor(0x0233,0x00 );          //0x0233	0x00                0x0233	0x00         0x0233	0x00             0x0233	0x00                     0x0233	0x00      0x0233	0x00 
write_cmos_sensor(0x0234,0x00 );          //0x0234	0x00                0x0234	0x00         0x0234	0x00             0x0234	0x00                     0x0234	0x00      0x0234	0x00 
write_cmos_sensor(0x0235,0x40 );          //0x0235	0x40                0x0235	0x40         0x0235	0x40             0x0235	0x40                     0x0235	0x40      0x0235	0x40 
write_cmos_sensor(0x0238,0x00 );          //0x0238	0x00                0x0238	0x00         0x0238	0x00             0x0238	0x00                     0x0238	0x00      0x0238	0x00 
write_cmos_sensor(0x0239,0x04 );          //0x0239	0x04                0x0239	0x04         0x0239	0x04             0x0239	0x04                     0x0239	0x04      0x0239	0x04 
write_cmos_sensor(0x023B,0x00 );          //0x023B	0x00                0x023B	0x00         0x023B	0x00             0x023B	0x00                     0x023B	0x00      0x023B	0x00 
write_cmos_sensor(0x023C,0x01 );          //0x023C	0x01                0x023C	0x01         0x023C	0x01             0x023C	0x01                     0x023C	0x01      0x023C	0x01 
write_cmos_sensor(0x33B0,0x04 );          //0x33B0	0x04                0x33B0	0x04         0x33B0	0x04             0x33B0	0x04                     0x33B0	0x04      0x33B0	0x04 
write_cmos_sensor(0x33B1,0x00 );          //0x33B1	0x00                0x33B1	0x00         0x33B1	0x00             0x33B1	0x00                     0x33B1	0x00      0x33B1	0x00 
write_cmos_sensor(0x33B3,0x00 );          //0x33B3	0x00                0x33B3	0x00         0x33B3	0x00             0x33B3	0x00                     0x33B3	0x00      0x33B3	0x00 
write_cmos_sensor(0x33B4,0x01 );          //0x33B4	0x01                0x33B4	0x01         0x33B4	0x01             0x33B4	0x01                     0x33B4	0x01      0x33B4	0x01 
write_cmos_sensor(0x3800,0x00 );          //0x3800	0x00                0x3800	0x00         0x3800	0x00             0x3800	0x00                     0x3800	0x00      0x3800	0x00 



	write_cmos_sensor(0x0104, 0x00);//group
	write_cmos_sensor(0x0100, 0x01);//STREAM ON
	// The register only need to enable 1 time.    
}
	
static void hs_video_setting()
	{
		write_cmos_sensor(0x0104, 0x01);//group
		write_cmos_sensor(0x0100, 0x00);//STREAM OFF 	
		//write_cmos_sensor(0x0103, 0x01);//SW reset
	
	
		//Clock Setting 																   //24fps				 //29fps			   //dummy pixel 360 binning		//232M pixel	 //232				 
	write_cmos_sensor(0x011E,0x18 ); 		 //0x011E	0x18			  //0x011E	0x18		 0x011E 0x18			 0x011E 0x18					 0x011E 0x18	  0x011E	0x18 
	write_cmos_sensor(0x011F,0x00 ); 		 //0x011F	0x00				0x011F	0x00		 0x011F 0x00			 0x011F 0x00					 0x011F 0x00	  0x011F	0x00 
		write_cmos_sensor(0x0301,0x0A);
	write_cmos_sensor(0x0303,0x01 ); 		 //0x0303	0x01				0x0303	0x01		 0x0303 0x01			 0x0303 0x01					 0x0303 0x01	  0x0303	0x01 
	write_cmos_sensor(0x0305,0x0C ); 		 //0x0305	0x0C				0x0305	0x0C		 0x0305 0x0C			 0x0305 0x0C					 0x0305 0x0C	  0x0305	0x0C 
		write_cmos_sensor(0x0309,0x0A);
	write_cmos_sensor(0x030B,0x01 ); 		 //0x030B	0x01				0x030B	0x01		 0x030B 0x01			 0x030B 0x01					 0x030B 0x01	  0x030B	0x01 
	write_cmos_sensor(0x030C,0x01 ); 		 //0x030C	0x01				0x030C	0x01		 0x030C 0x01			 0x030C 0x00					 0x030C 0x01	  0x030C	0x01 
		write_cmos_sensor(0x030D,0xF3);
	write_cmos_sensor(0x030E,0x01 ); 		 //0x030E	0x01				0x030E	0x01		 0x030E 0x01			 0x030E 0x01					 0x030E 0x01	  0x030E	0x01 
	write_cmos_sensor(0x3A06,0x11 ); 		 //0x3A06	0x11				0x3A06	0x11		 0x3A06 0x11			 0x3A06 0x11					 0x3A06 0x11	  0x3A06	0x11 
	//Mode setting										   //																																		   
		write_cmos_sensor(0x0108,0x01);
	write_cmos_sensor(0x0112,0x0A ); 		 //0x0112	0x0A				0x0112	0x0A		 0x0112 0x0A			 0x0112 0x0A					 0x0112 0x0A	  0x0112	0x0A 
	write_cmos_sensor(0x0113,0x0A ); 		 //0x0113	0x0A				0x0113	0x0A		 0x0113 0x0A			 0x0113 0x0A					 0x0113 0x0A	  0x0113	0x0A 
	write_cmos_sensor(0x0381,0x01 ); 		 //0x0381	0x01				0x0381	0x01		 0x0381 0x01			 0x0381 0x01					 0x0381 0x01	  0x0381	0x01 
	write_cmos_sensor(0x0383,0x01 ); 		 //0x0383	0x01				0x0383	0x01		 0x0383 0x01			 0x0383 0x01					 0x0383 0x01	  0x0383	0x01 
	write_cmos_sensor(0x0385,0x01 ); 		 //0x0385	0x01				0x0385	0x01		 0x0385 0x01			 0x0385 0x01					 0x0385 0x01	  0x0385	0x01 
	write_cmos_sensor(0x0387,0x01 ); 		 //0x0387	0x01				0x0387	0x01		 0x0387 0x01			 0x0387 0x01					 0x0387 0x01	  0x0387	0x01 
	write_cmos_sensor(0x0390,0x01 ); 		 //0x0390	0x00				0x0390	0x01		 0x0390 0x01			 0x0390 0x01					 0x0390 0x01	  0x0390	0x01 
	write_cmos_sensor(0x0391,0x22 ); 		 //0x0391	0x11				0x0391	0x22		 0x0391 0x22			 0x0391 0x22					 0x0391 0x22	  0x0391	0x22 
	write_cmos_sensor(0x0392,0x00 ); 		 //0x0392	0x00				0x0392	0x00		 0x0392 0x00			 0x0392 0x00					 0x0392 0x00	  0x0392	0x00 
	write_cmos_sensor(0x0401,0x00 ); 		 //0x0401	0x02				0x0401	0x00		 0x0401 0x00			 0x0401 0x00					 0x0401 0x00	  0x0401	0x00 
	write_cmos_sensor(0x0404,0x00 ); 		 //0x0404	0x00				0x0404	0x00		 0x0404 0x00			 0x0404 0x00					 0x0404 0x00	  0x0404	0x00 
	write_cmos_sensor(0x0405,0x10 ); 		 //0x0405	0x20				0x0405	0x10		 0x0405 0x10			 0x0405 0x10					 0x0405 0x10	  0x0405	0x10 
	write_cmos_sensor(0x4082,0x01 ); 		 //0x4082	0x00				0x4082	0x01		 0x4082 0x01			 0x4082 0x01					 0x4082 0x01	  0x4082	0x01 
	write_cmos_sensor(0x4083,0x01 ); 		 //0x4083	0x00				0x4083	0x01		 0x4083 0x01			 0x4083 0x01					 0x4083 0x01	  0x4083	0x01 
	write_cmos_sensor(0x7006,0x04 ); 		 //0x7006	0x04				0x7006	0x04		 0x7006 0x04			 0x7006 0x04					 0x7006 0x04	  0x7006	0x04 
	//OptionnalFunction setting 						   //																																		   
	write_cmos_sensor(0x0700,0x00 ); 		 //0x0700	0x00				0x0700	0x00		 0x0700 0x00			 0x0700 0x00					 0x0700 0x00	  0x0700	0x00 
	write_cmos_sensor(0x3A63,0x00 ); 		 //0x3A63	0x00				0x3A63	0x00		 0x3A63 0x00			 0x3A63 0x00					 0x3A63 0x00	  0x3A63	0x00 
	write_cmos_sensor(0x4100,0xF8 ); 		 //0x4100	0xF8				0x4100	0xF8		 0x4100 0xF8			 0x4100 0xF8					 0x4100 0xF8	  0x4100	0xF8 
	write_cmos_sensor(0x4203,0xFF ); 		 //0x4203	0xFF				0x4203	0xFF		 0x4203 0xFF			 0x4203 0xFF					 0x4203 0xFF	  0x4203	0xFF 
	write_cmos_sensor(0x4344,0x00 ); 		 //0x4344	0x00				0x4344	0x00		 0x4344 0x00			 0x4344 0x00					 0x4344 0x00	  0x4344	0x00 
	write_cmos_sensor(0x441C,0x01 ); 		 //0x441C	0x01				0x441C	0x01		 0x441C 0x01			 0x441C 0x01					 0x441C 0x01	  0x441C	0x01 
	//Size setting										   //																																		   
	write_cmos_sensor(0x0340,0x07 ); 		 //0x0340	0x08				0x0340	0x0A		 0x0340 0x09			 0x0340 0x06					 0x0340 0x07	  0x0340	0x07 
		write_cmos_sensor(0x0341,0x38);
		write_cmos_sensor(0x0342,0x0E);
		write_cmos_sensor(0x0343,0x10);
	write_cmos_sensor(0x0344,0x00 ); 		 //0x0344	0x00				0x0344	0x00		 0x0344 0x00			 0x0344 0x00					 0x0344 0x00	  0x0344	0x00 
	write_cmos_sensor(0x0345,0x00 ); 		 //0x0345	0x00				0x0345	0x08		 0x0345 0x08			 0x0345 0x00					 0x0345 0x00	  0x0345	0x00 
	write_cmos_sensor(0x0346,0x00 ); 		 //0x0346	0x00				0x0346	0x00		 0x0346 0x00			 0x0346 0x00					 0x0346 0x00	  0x0346	0x00 
	write_cmos_sensor(0x0347,0x00 ); 		 //0x0347	0x00				0x0347	0x08		 0x0347 0x14			 0x0347 0x00					 0x0347 0x00	  0x0347	0x00 
	write_cmos_sensor(0x0348,0x0C ); 		 //0x0348	0x0C				0x0348	0x0C		 0x0348 0x0C			 0x0348 0x0C					 0x0348 0x0C	  0x0348	0x0C 
	write_cmos_sensor(0x0349,0xCF ); 		 //0x0349	0xCF				0x0349	0xC7		 0x0349 0xC7			 0x0349 0xCF					 0x0349 0xCF	  0x0349	0xCF 
	write_cmos_sensor(0x034A,0x09 ); 		 //0x034A	0x09				0x034A	0x09		 0x034A 0x09			 0x034A 0x09					 0x034A 0x09	  0x034A	0x09 
	write_cmos_sensor(0x034B,0x9F ); 		 //0x034B	0x9F				0x034B	0x97		 0x034B 0x8B			 0x034B 0x9F					 0x034B 0x9F	  0x034B	0x9F 
	write_cmos_sensor(0x034C,0x06 ); 		 //0x034C	0x06				0x034C	0x06		 0x034C 0x06			 0x034C 0x06					 0x034C 0x06	  0x034C	0x06 
	write_cmos_sensor(0x034D,0x68 ); 		 //0x034D	0x68				0x034D	0x60		 0x034D 0x60			 0x034D 0x68					 0x034D 0x68	  0x034D	0x68 
	write_cmos_sensor(0x034E,0x04 ); 		 //0x034E	0x04				0x034E	0x04		 0x034E 0x04			 0x034E 0x04					 0x034E 0x04	  0x034E	0x04 
	write_cmos_sensor(0x034F,0xD0 ); 		 //0x034F	0xD0				0x034F	0xC8		 0x034F 0xBC			 0x034F 0xD0					 0x034F 0xD0	  0x034F	0xD0 
	write_cmos_sensor(0x0350,0x00 ); 		 //0x0350	0x00				0x0350	0x00		 0x0350 0x00			 0x0350 0x00					 0x0350 0x00	  0x0350	0x00 
	write_cmos_sensor(0x0351,0x00 ); 		 //0x0351	0x00				0x0351	0x00		 0x0351 0x00			 0x0351 0x00					 0x0351 0x00	  0x0351	0x00 
	write_cmos_sensor(0x0352,0x00 ); 		 //0x0352	0x00				0x0352	0x00		 0x0352 0x00			 0x0352 0x00					 0x0352 0x00	  0x0352	0x00 
	write_cmos_sensor(0x0353,0x00 ); 		 //0x0353	0x00				0x0353	0x00		 0x0353 0x00			 0x0353 0x00					 0x0353 0x00	  0x0353	0x00 
	write_cmos_sensor(0x0354,0x06 ); 		 //0x0354	0x0C				0x0354	0x06		 0x0354 0x06			 0x0354 0x06					 0x0354 0x06	  0x0354	0x06 
	write_cmos_sensor(0x0355,0x68 ); 		 //0x0355	0xD0				0x0355	0x60		 0x0355 0x60			 0x0355 0x68					 0x0355 0x68	  0x0355	0x68 
	write_cmos_sensor(0x0356,0x04 ); 		 //0x0356	0x09				0x0356	0x04		 0x0356 0x04			 0x0356 0x04					 0x0356 0x04	  0x0356	0x04 
	write_cmos_sensor(0x0357,0xD0 ); 		 //0x0357	0xA0				0x0357	0xC8		 0x0357 0xBC			 0x0357 0xD0					 0x0357 0xD0	  0x0357	0xD0 
	write_cmos_sensor(0x301D,0x30 ); 		 //0x301D	0x30				0x301D	0x30		 0x301D 0x30			 0x301D 0x30					 0x301D 0x30	  0x301D	0x30 
	write_cmos_sensor(0x3310,0x06 ); 		 //0x3310	0x06				0x3310	0x06		 0x3310 0x06			 0x3310 0x06					 0x3310 0x06	  0x3310	0x06 
	write_cmos_sensor(0x3311,0x68 ); 		 //0x3311	0x68				0x3311	0x60		 0x3311 0x60			 0x3311 0x68					 0x3311 0x68	  0x3311	0x68 
	write_cmos_sensor(0x3312,0x04 ); 		 //0x3312	0x04				0x3312	0x04		 0x3312 0x04			 0x3312 0x04					 0x3312 0x04	  0x3312	0x04 
	write_cmos_sensor(0x3313,0xD0 ); 		 //0x3313	0xD0				0x3313	0xC8		 0x3313 0xBC			 0x3313 0xD0					 0x3313 0xD0	  0x3313	0xD0 
	write_cmos_sensor(0x331C,0x04 ); 		 //0x331C	0x04				0x331C	0x04		 0x331C 0x04			 0x331C 0x04					 0x331C 0x04	  0x331C	0x04 
	write_cmos_sensor(0x331D,0x06 ); 		 //0x331D	0x1E				0x331D	0x06		 0x331D 0x06			 0x331D 0x06					 0x331D 0x06	  0x331D	0x06 
	write_cmos_sensor(0x4084,0x00 ); 		 //0x4084	0x06				0x4084	0x00		 0x4084 0x00			 0x4084 0x00					 0x4084 0x00	  0x4084	0x00 
	write_cmos_sensor(0x4085,0x00 ); 		 //0x4085	0x68				0x4085	0x00		 0x4085 0x00			 0x4085 0x00					 0x4085 0x00	  0x4085	0x00 
	write_cmos_sensor(0x4086,0x00 ); 		 //0x4086	0x04				0x4086	0x00		 0x4086 0x00			 0x4086 0x00					 0x4086 0x00	  0x4086	0x00 
	write_cmos_sensor(0x4087,0x00 ); 		 //0x4087	0xD0				0x4087	0x00		 0x4087 0x00			 0x4087 0x00					 0x4087 0x00	  0x4087	0x00 
	write_cmos_sensor(0x4400,0x00 ); 		 //0x4400	0x00				0x4400	0x00		 0x4400 0x00			 0x4400 0x00					 0x4400 0x00	  0x4400	0x00 
	//Global Timing Setting 							   //																																		   
		write_cmos_sensor(0x0830,0x87);
		write_cmos_sensor(0x0831,0x3F);
		write_cmos_sensor(0x0832,0x77);
		write_cmos_sensor(0x0833,0x47);
		write_cmos_sensor(0x0834,0x47);
		write_cmos_sensor(0x0835,0x57);
		write_cmos_sensor(0x0836,0xF7);
		write_cmos_sensor(0x0837,0x4F);
	write_cmos_sensor(0x0839,0x1F ); 		 //0x0839	0x1F				0x0839	0x1F		 0x0839 0x1F			 0x0839 0x1F					 0x0839 0x1F	  0x0839	0x1F 
	write_cmos_sensor(0x083A,0x17 ); 		 //0x083A	0x17				0x083A	0x17		 0x083A 0x17			 0x083A 0x17					 0x083A 0x17	  0x083A	0x17 
	write_cmos_sensor(0x083B,0x02 ); 		 //0x083B	0x02				0x083B	0x02		 0x083B 0x02			 0x083B 0x02					 0x083B 0x02	  0x083B	0x02 
	//Integration Time Setting							   //																																		   
	write_cmos_sensor(0x0202,0x07 ); 		 //0x0202	0x08				0x0202	0x0A		 0x0202 0x09			 0x0202 0x06					 0x0202 0x07	  0x0202	0x07 
		write_cmos_sensor(0x0203,0x34);
	//Gain Setting										   //																																		   
	write_cmos_sensor(0x0205,0x00 ); 		 //0x0205	0x00				0x0205	0x00		 0x0205 0x00			 0x0205 0x00					 0x0205 0x00	  0x0205	0x00 
	write_cmos_sensor(0x020E,0x01 ); 		 //0x020E	0x01				0x020E	0x01		 0x020E 0x01			 0x020E 0x01					 0x020E 0x01	  0x020E	0x01 
	write_cmos_sensor(0x020F,0x00 ); 		 //0x020F	0x00				0x020F	0x00		 0x020F 0x00			 0x020F 0x00					 0x020F 0x00	  0x020F	0x00 
	write_cmos_sensor(0x0210,0x01 ); 		 //0x0210	0x01				0x0210	0x01		 0x0210 0x01			 0x0210 0x01					 0x0210 0x01	  0x0210	0x01 
	write_cmos_sensor(0x0211,0x00 ); 		 //0x0211	0x00				0x0211	0x00		 0x0211 0x00			 0x0211 0x00					 0x0211 0x00	  0x0211	0x00 
	write_cmos_sensor(0x0212,0x01 ); 		 //0x0212	0x01				0x0212	0x01		 0x0212 0x01			 0x0212 0x01					 0x0212 0x01	  0x0212	0x01 
	write_cmos_sensor(0x0213,0x00 ); 		 //0x0213	0x00				0x0213	0x00		 0x0213 0x00			 0x0213 0x00					 0x0213 0x00	  0x0213	0x00 
	write_cmos_sensor(0x0214,0x01 ); 		 //0x0214	0x01				0x0214	0x01		 0x0214 0x01			 0x0214 0x01					 0x0214 0x01	  0x0214	0x01 
	write_cmos_sensor(0x0215,0x00 ); 		 //0x0215	0x00				0x0215	0x00		 0x0215 0x00			 0x0215 0x00					 0x0215 0x00	  0x0215	0x00 
	//HDR Setting											 // 																																	   
	write_cmos_sensor(0x0230,0x00 ); 		 //0x0230	0x00				0x0230	0x00		 0x0230 0x00			 0x0230 0x00					 0x0230 0x00	  0x0230	0x00 
	write_cmos_sensor(0x0231,0x00 ); 		 //0x0231	0x00				0x0231	0x00		 0x0231 0x00			 0x0231 0x00					 0x0231 0x00	  0x0231	0x00 
	write_cmos_sensor(0x0233,0x00 ); 		 //0x0233	0x00				0x0233	0x00		 0x0233 0x00			 0x0233 0x00					 0x0233 0x00	  0x0233	0x00 
	write_cmos_sensor(0x0234,0x00 ); 		 //0x0234	0x00				0x0234	0x00		 0x0234 0x00			 0x0234 0x00					 0x0234 0x00	  0x0234	0x00 
	write_cmos_sensor(0x0235,0x40 ); 		 //0x0235	0x40				0x0235	0x40		 0x0235 0x40			 0x0235 0x40					 0x0235 0x40	  0x0235	0x40 
	write_cmos_sensor(0x0238,0x00 ); 		 //0x0238	0x00				0x0238	0x00		 0x0238 0x00			 0x0238 0x00					 0x0238 0x00	  0x0238	0x00 
	write_cmos_sensor(0x0239,0x04 ); 		 //0x0239	0x04				0x0239	0x04		 0x0239 0x04			 0x0239 0x04					 0x0239 0x04	  0x0239	0x04 
	write_cmos_sensor(0x023B,0x00 ); 		 //0x023B	0x00				0x023B	0x00		 0x023B 0x00			 0x023B 0x00					 0x023B 0x00	  0x023B	0x00 
	write_cmos_sensor(0x023C,0x01 ); 		 //0x023C	0x01				0x023C	0x01		 0x023C 0x01			 0x023C 0x01					 0x023C 0x01	  0x023C	0x01 
	write_cmos_sensor(0x33B0,0x04 ); 		 //0x33B0	0x04				0x33B0	0x04		 0x33B0 0x04			 0x33B0 0x04					 0x33B0 0x04	  0x33B0	0x04 
	write_cmos_sensor(0x33B1,0x00 ); 		 //0x33B1	0x00				0x33B1	0x00		 0x33B1 0x00			 0x33B1 0x00					 0x33B1 0x00	  0x33B1	0x00 
	write_cmos_sensor(0x33B3,0x00 ); 		 //0x33B3	0x00				0x33B3	0x00		 0x33B3 0x00			 0x33B3 0x00					 0x33B3 0x00	  0x33B3	0x00 
	write_cmos_sensor(0x33B4,0x01 ); 		 //0x33B4	0x01				0x33B4	0x01		 0x33B4 0x01			 0x33B4 0x01					 0x33B4 0x01	  0x33B4	0x01 
	write_cmos_sensor(0x3800,0x00 ); 		 //0x3800	0x00				0x3800	0x00		 0x3800 0x00			 0x3800 0x00					 0x3800 0x00	  0x3800	0x00 
	
	
	
		write_cmos_sensor(0x0104, 0x00);//group
		write_cmos_sensor(0x0100, 0x01);//STREAM ON
		// The register only need to enable 1 time.    
	}


static void slim_video_setting()
	{
		write_cmos_sensor(0x0104, 0x01);//group
		write_cmos_sensor(0x0100, 0x00);//STREAM OFF 	
		//write_cmos_sensor(0x0103, 0x01);//SW reset
	
	
		//Clock Setting 																   //24fps				 //29fps			   //dummy pixel 360 binning		//232M pixel	 //232				 
	write_cmos_sensor(0x011E,0x18 ); 		 //0x011E	0x18			  //0x011E	0x18		 0x011E 0x18			 0x011E 0x18					 0x011E 0x18	  0x011E	0x18 
	write_cmos_sensor(0x011F,0x00 ); 		 //0x011F	0x00				0x011F	0x00		 0x011F 0x00			 0x011F 0x00					 0x011F 0x00	  0x011F	0x00 
		write_cmos_sensor(0x0301,0x0A);
	write_cmos_sensor(0x0303,0x01 ); 		 //0x0303	0x01				0x0303	0x01		 0x0303 0x01			 0x0303 0x01					 0x0303 0x01	  0x0303	0x01 
	write_cmos_sensor(0x0305,0x0C ); 		 //0x0305	0x0C				0x0305	0x0C		 0x0305 0x0C			 0x0305 0x0C					 0x0305 0x0C	  0x0305	0x0C 
		write_cmos_sensor(0x0309,0x0A);
	write_cmos_sensor(0x030B,0x01 ); 		 //0x030B	0x01				0x030B	0x01		 0x030B 0x01			 0x030B 0x01					 0x030B 0x01	  0x030B	0x01 
	write_cmos_sensor(0x030C,0x01 ); 		 //0x030C	0x01				0x030C	0x01		 0x030C 0x01			 0x030C 0x00					 0x030C 0x01	  0x030C	0x01 
		write_cmos_sensor(0x030D,0xF3);
	write_cmos_sensor(0x030E,0x01 ); 		 //0x030E	0x01				0x030E	0x01		 0x030E 0x01			 0x030E 0x01					 0x030E 0x01	  0x030E	0x01 
	write_cmos_sensor(0x3A06,0x11 ); 		 //0x3A06	0x11				0x3A06	0x11		 0x3A06 0x11			 0x3A06 0x11					 0x3A06 0x11	  0x3A06	0x11 
	//Mode setting										   //																																		   
		write_cmos_sensor(0x0108,0x01);
	write_cmos_sensor(0x0112,0x0A ); 		 //0x0112	0x0A				0x0112	0x0A		 0x0112 0x0A			 0x0112 0x0A					 0x0112 0x0A	  0x0112	0x0A 
	write_cmos_sensor(0x0113,0x0A ); 		 //0x0113	0x0A				0x0113	0x0A		 0x0113 0x0A			 0x0113 0x0A					 0x0113 0x0A	  0x0113	0x0A 
	write_cmos_sensor(0x0381,0x01 ); 		 //0x0381	0x01				0x0381	0x01		 0x0381 0x01			 0x0381 0x01					 0x0381 0x01	  0x0381	0x01 
	write_cmos_sensor(0x0383,0x01 ); 		 //0x0383	0x01				0x0383	0x01		 0x0383 0x01			 0x0383 0x01					 0x0383 0x01	  0x0383	0x01 
	write_cmos_sensor(0x0385,0x01 ); 		 //0x0385	0x01				0x0385	0x01		 0x0385 0x01			 0x0385 0x01					 0x0385 0x01	  0x0385	0x01 
	write_cmos_sensor(0x0387,0x01 ); 		 //0x0387	0x01				0x0387	0x01		 0x0387 0x01			 0x0387 0x01					 0x0387 0x01	  0x0387	0x01 
	write_cmos_sensor(0x0390,0x01 ); 		 //0x0390	0x00				0x0390	0x01		 0x0390 0x01			 0x0390 0x01					 0x0390 0x01	  0x0390	0x01 
	write_cmos_sensor(0x0391,0x22 ); 		 //0x0391	0x11				0x0391	0x22		 0x0391 0x22			 0x0391 0x22					 0x0391 0x22	  0x0391	0x22 
	write_cmos_sensor(0x0392,0x00 ); 		 //0x0392	0x00				0x0392	0x00		 0x0392 0x00			 0x0392 0x00					 0x0392 0x00	  0x0392	0x00 
	write_cmos_sensor(0x0401,0x00 ); 		 //0x0401	0x02				0x0401	0x00		 0x0401 0x00			 0x0401 0x00					 0x0401 0x00	  0x0401	0x00 
	write_cmos_sensor(0x0404,0x00 ); 		 //0x0404	0x00				0x0404	0x00		 0x0404 0x00			 0x0404 0x00					 0x0404 0x00	  0x0404	0x00 
	write_cmos_sensor(0x0405,0x10 ); 		 //0x0405	0x20				0x0405	0x10		 0x0405 0x10			 0x0405 0x10					 0x0405 0x10	  0x0405	0x10 
	write_cmos_sensor(0x4082,0x01 ); 		 //0x4082	0x00				0x4082	0x01		 0x4082 0x01			 0x4082 0x01					 0x4082 0x01	  0x4082	0x01 
	write_cmos_sensor(0x4083,0x01 ); 		 //0x4083	0x00				0x4083	0x01		 0x4083 0x01			 0x4083 0x01					 0x4083 0x01	  0x4083	0x01 
	write_cmos_sensor(0x7006,0x04 ); 		 //0x7006	0x04				0x7006	0x04		 0x7006 0x04			 0x7006 0x04					 0x7006 0x04	  0x7006	0x04 
	//OptionnalFunction setting 						   //																																		   
	write_cmos_sensor(0x0700,0x00 ); 		 //0x0700	0x00				0x0700	0x00		 0x0700 0x00			 0x0700 0x00					 0x0700 0x00	  0x0700	0x00 
	write_cmos_sensor(0x3A63,0x00 ); 		 //0x3A63	0x00				0x3A63	0x00		 0x3A63 0x00			 0x3A63 0x00					 0x3A63 0x00	  0x3A63	0x00 
	write_cmos_sensor(0x4100,0xF8 ); 		 //0x4100	0xF8				0x4100	0xF8		 0x4100 0xF8			 0x4100 0xF8					 0x4100 0xF8	  0x4100	0xF8 
	write_cmos_sensor(0x4203,0xFF ); 		 //0x4203	0xFF				0x4203	0xFF		 0x4203 0xFF			 0x4203 0xFF					 0x4203 0xFF	  0x4203	0xFF 
	write_cmos_sensor(0x4344,0x00 ); 		 //0x4344	0x00				0x4344	0x00		 0x4344 0x00			 0x4344 0x00					 0x4344 0x00	  0x4344	0x00 
	write_cmos_sensor(0x441C,0x01 ); 		 //0x441C	0x01				0x441C	0x01		 0x441C 0x01			 0x441C 0x01					 0x441C 0x01	  0x441C	0x01 
	//Size setting										   //																																		   
	write_cmos_sensor(0x0340,0x07 ); 		 //0x0340	0x08				0x0340	0x0A		 0x0340 0x09			 0x0340 0x06					 0x0340 0x07	  0x0340	0x07 
		write_cmos_sensor(0x0341,0x38);
		write_cmos_sensor(0x0342,0x0E);
		write_cmos_sensor(0x0343,0x10);
	write_cmos_sensor(0x0344,0x00 ); 		 //0x0344	0x00				0x0344	0x00		 0x0344 0x00			 0x0344 0x00					 0x0344 0x00	  0x0344	0x00 
	write_cmos_sensor(0x0345,0x00 ); 		 //0x0345	0x00				0x0345	0x08		 0x0345 0x08			 0x0345 0x00					 0x0345 0x00	  0x0345	0x00 
	write_cmos_sensor(0x0346,0x00 ); 		 //0x0346	0x00				0x0346	0x00		 0x0346 0x00			 0x0346 0x00					 0x0346 0x00	  0x0346	0x00 
	write_cmos_sensor(0x0347,0x00 ); 		 //0x0347	0x00				0x0347	0x08		 0x0347 0x14			 0x0347 0x00					 0x0347 0x00	  0x0347	0x00 
	write_cmos_sensor(0x0348,0x0C ); 		 //0x0348	0x0C				0x0348	0x0C		 0x0348 0x0C			 0x0348 0x0C					 0x0348 0x0C	  0x0348	0x0C 
	write_cmos_sensor(0x0349,0xCF ); 		 //0x0349	0xCF				0x0349	0xC7		 0x0349 0xC7			 0x0349 0xCF					 0x0349 0xCF	  0x0349	0xCF 
	write_cmos_sensor(0x034A,0x09 ); 		 //0x034A	0x09				0x034A	0x09		 0x034A 0x09			 0x034A 0x09					 0x034A 0x09	  0x034A	0x09 
	write_cmos_sensor(0x034B,0x9F ); 		 //0x034B	0x9F				0x034B	0x97		 0x034B 0x8B			 0x034B 0x9F					 0x034B 0x9F	  0x034B	0x9F 
	write_cmos_sensor(0x034C,0x06 ); 		 //0x034C	0x06				0x034C	0x06		 0x034C 0x06			 0x034C 0x06					 0x034C 0x06	  0x034C	0x06 
	write_cmos_sensor(0x034D,0x68 ); 		 //0x034D	0x68				0x034D	0x60		 0x034D 0x60			 0x034D 0x68					 0x034D 0x68	  0x034D	0x68 
	write_cmos_sensor(0x034E,0x04 ); 		 //0x034E	0x04				0x034E	0x04		 0x034E 0x04			 0x034E 0x04					 0x034E 0x04	  0x034E	0x04 
	write_cmos_sensor(0x034F,0xD0 ); 		 //0x034F	0xD0				0x034F	0xC8		 0x034F 0xBC			 0x034F 0xD0					 0x034F 0xD0	  0x034F	0xD0 
	write_cmos_sensor(0x0350,0x00 ); 		 //0x0350	0x00				0x0350	0x00		 0x0350 0x00			 0x0350 0x00					 0x0350 0x00	  0x0350	0x00 
	write_cmos_sensor(0x0351,0x00 ); 		 //0x0351	0x00				0x0351	0x00		 0x0351 0x00			 0x0351 0x00					 0x0351 0x00	  0x0351	0x00 
	write_cmos_sensor(0x0352,0x00 ); 		 //0x0352	0x00				0x0352	0x00		 0x0352 0x00			 0x0352 0x00					 0x0352 0x00	  0x0352	0x00 
	write_cmos_sensor(0x0353,0x00 ); 		 //0x0353	0x00				0x0353	0x00		 0x0353 0x00			 0x0353 0x00					 0x0353 0x00	  0x0353	0x00 
	write_cmos_sensor(0x0354,0x06 ); 		 //0x0354	0x0C				0x0354	0x06		 0x0354 0x06			 0x0354 0x06					 0x0354 0x06	  0x0354	0x06 
	write_cmos_sensor(0x0355,0x68 ); 		 //0x0355	0xD0				0x0355	0x60		 0x0355 0x60			 0x0355 0x68					 0x0355 0x68	  0x0355	0x68 
	write_cmos_sensor(0x0356,0x04 ); 		 //0x0356	0x09				0x0356	0x04		 0x0356 0x04			 0x0356 0x04					 0x0356 0x04	  0x0356	0x04 
	write_cmos_sensor(0x0357,0xD0 ); 		 //0x0357	0xA0				0x0357	0xC8		 0x0357 0xBC			 0x0357 0xD0					 0x0357 0xD0	  0x0357	0xD0 
	write_cmos_sensor(0x301D,0x30 ); 		 //0x301D	0x30				0x301D	0x30		 0x301D 0x30			 0x301D 0x30					 0x301D 0x30	  0x301D	0x30 
	write_cmos_sensor(0x3310,0x06 ); 		 //0x3310	0x06				0x3310	0x06		 0x3310 0x06			 0x3310 0x06					 0x3310 0x06	  0x3310	0x06 
	write_cmos_sensor(0x3311,0x68 ); 		 //0x3311	0x68				0x3311	0x60		 0x3311 0x60			 0x3311 0x68					 0x3311 0x68	  0x3311	0x68 
	write_cmos_sensor(0x3312,0x04 ); 		 //0x3312	0x04				0x3312	0x04		 0x3312 0x04			 0x3312 0x04					 0x3312 0x04	  0x3312	0x04 
	write_cmos_sensor(0x3313,0xD0 ); 		 //0x3313	0xD0				0x3313	0xC8		 0x3313 0xBC			 0x3313 0xD0					 0x3313 0xD0	  0x3313	0xD0 
	write_cmos_sensor(0x331C,0x04 ); 		 //0x331C	0x04				0x331C	0x04		 0x331C 0x04			 0x331C 0x04					 0x331C 0x04	  0x331C	0x04 
	write_cmos_sensor(0x331D,0x06 ); 		 //0x331D	0x1E				0x331D	0x06		 0x331D 0x06			 0x331D 0x06					 0x331D 0x06	  0x331D	0x06 
	write_cmos_sensor(0x4084,0x00 ); 		 //0x4084	0x06				0x4084	0x00		 0x4084 0x00			 0x4084 0x00					 0x4084 0x00	  0x4084	0x00 
	write_cmos_sensor(0x4085,0x00 ); 		 //0x4085	0x68				0x4085	0x00		 0x4085 0x00			 0x4085 0x00					 0x4085 0x00	  0x4085	0x00 
	write_cmos_sensor(0x4086,0x00 ); 		 //0x4086	0x04				0x4086	0x00		 0x4086 0x00			 0x4086 0x00					 0x4086 0x00	  0x4086	0x00 
	write_cmos_sensor(0x4087,0x00 ); 		 //0x4087	0xD0				0x4087	0x00		 0x4087 0x00			 0x4087 0x00					 0x4087 0x00	  0x4087	0x00 
	write_cmos_sensor(0x4400,0x00 ); 		 //0x4400	0x00				0x4400	0x00		 0x4400 0x00			 0x4400 0x00					 0x4400 0x00	  0x4400	0x00 
	//Global Timing Setting 							   //																																		   
		write_cmos_sensor(0x0830,0x87);
		write_cmos_sensor(0x0831,0x3F);
		write_cmos_sensor(0x0832,0x77);
		write_cmos_sensor(0x0833,0x47);
		write_cmos_sensor(0x0834,0x47);
		write_cmos_sensor(0x0835,0x57);
		write_cmos_sensor(0x0836,0xF7);
		write_cmos_sensor(0x0837,0x4F);
	write_cmos_sensor(0x0839,0x1F ); 		 //0x0839	0x1F				0x0839	0x1F		 0x0839 0x1F			 0x0839 0x1F					 0x0839 0x1F	  0x0839	0x1F 
	write_cmos_sensor(0x083A,0x17 ); 		 //0x083A	0x17				0x083A	0x17		 0x083A 0x17			 0x083A 0x17					 0x083A 0x17	  0x083A	0x17 
	write_cmos_sensor(0x083B,0x02 ); 		 //0x083B	0x02				0x083B	0x02		 0x083B 0x02			 0x083B 0x02					 0x083B 0x02	  0x083B	0x02 
	//Integration Time Setting							   //																																		   
	write_cmos_sensor(0x0202,0x07 ); 		 //0x0202	0x08				0x0202	0x0A		 0x0202 0x09			 0x0202 0x06					 0x0202 0x07	  0x0202	0x07 
		write_cmos_sensor(0x0203,0x34);
	//Gain Setting										   //																																		   
	write_cmos_sensor(0x0205,0x00 ); 		 //0x0205	0x00				0x0205	0x00		 0x0205 0x00			 0x0205 0x00					 0x0205 0x00	  0x0205	0x00 
	write_cmos_sensor(0x020E,0x01 ); 		 //0x020E	0x01				0x020E	0x01		 0x020E 0x01			 0x020E 0x01					 0x020E 0x01	  0x020E	0x01 
	write_cmos_sensor(0x020F,0x00 ); 		 //0x020F	0x00				0x020F	0x00		 0x020F 0x00			 0x020F 0x00					 0x020F 0x00	  0x020F	0x00 
	write_cmos_sensor(0x0210,0x01 ); 		 //0x0210	0x01				0x0210	0x01		 0x0210 0x01			 0x0210 0x01					 0x0210 0x01	  0x0210	0x01 
	write_cmos_sensor(0x0211,0x00 ); 		 //0x0211	0x00				0x0211	0x00		 0x0211 0x00			 0x0211 0x00					 0x0211 0x00	  0x0211	0x00 
	write_cmos_sensor(0x0212,0x01 ); 		 //0x0212	0x01				0x0212	0x01		 0x0212 0x01			 0x0212 0x01					 0x0212 0x01	  0x0212	0x01 
	write_cmos_sensor(0x0213,0x00 ); 		 //0x0213	0x00				0x0213	0x00		 0x0213 0x00			 0x0213 0x00					 0x0213 0x00	  0x0213	0x00 
	write_cmos_sensor(0x0214,0x01 ); 		 //0x0214	0x01				0x0214	0x01		 0x0214 0x01			 0x0214 0x01					 0x0214 0x01	  0x0214	0x01 
	write_cmos_sensor(0x0215,0x00 ); 		 //0x0215	0x00				0x0215	0x00		 0x0215 0x00			 0x0215 0x00					 0x0215 0x00	  0x0215	0x00 
	//HDR Setting											 // 																																	   
	write_cmos_sensor(0x0230,0x00 ); 		 //0x0230	0x00				0x0230	0x00		 0x0230 0x00			 0x0230 0x00					 0x0230 0x00	  0x0230	0x00 
	write_cmos_sensor(0x0231,0x00 ); 		 //0x0231	0x00				0x0231	0x00		 0x0231 0x00			 0x0231 0x00					 0x0231 0x00	  0x0231	0x00 
	write_cmos_sensor(0x0233,0x00 ); 		 //0x0233	0x00				0x0233	0x00		 0x0233 0x00			 0x0233 0x00					 0x0233 0x00	  0x0233	0x00 
	write_cmos_sensor(0x0234,0x00 ); 		 //0x0234	0x00				0x0234	0x00		 0x0234 0x00			 0x0234 0x00					 0x0234 0x00	  0x0234	0x00 
	write_cmos_sensor(0x0235,0x40 ); 		 //0x0235	0x40				0x0235	0x40		 0x0235 0x40			 0x0235 0x40					 0x0235 0x40	  0x0235	0x40 
	write_cmos_sensor(0x0238,0x00 ); 		 //0x0238	0x00				0x0238	0x00		 0x0238 0x00			 0x0238 0x00					 0x0238 0x00	  0x0238	0x00 
	write_cmos_sensor(0x0239,0x04 ); 		 //0x0239	0x04				0x0239	0x04		 0x0239 0x04			 0x0239 0x04					 0x0239 0x04	  0x0239	0x04 
	write_cmos_sensor(0x023B,0x00 ); 		 //0x023B	0x00				0x023B	0x00		 0x023B 0x00			 0x023B 0x00					 0x023B 0x00	  0x023B	0x00 
	write_cmos_sensor(0x023C,0x01 ); 		 //0x023C	0x01				0x023C	0x01		 0x023C 0x01			 0x023C 0x01					 0x023C 0x01	  0x023C	0x01 
	write_cmos_sensor(0x33B0,0x04 ); 		 //0x33B0	0x04				0x33B0	0x04		 0x33B0 0x04			 0x33B0 0x04					 0x33B0 0x04	  0x33B0	0x04 
	write_cmos_sensor(0x33B1,0x00 ); 		 //0x33B1	0x00				0x33B1	0x00		 0x33B1 0x00			 0x33B1 0x00					 0x33B1 0x00	  0x33B1	0x00 
	write_cmos_sensor(0x33B3,0x00 ); 		 //0x33B3	0x00				0x33B3	0x00		 0x33B3 0x00			 0x33B3 0x00					 0x33B3 0x00	  0x33B3	0x00 
	write_cmos_sensor(0x33B4,0x01 ); 		 //0x33B4	0x01				0x33B4	0x01		 0x33B4 0x01			 0x33B4 0x01					 0x33B4 0x01	  0x33B4	0x01 
	write_cmos_sensor(0x3800,0x00 ); 		 //0x3800	0x00				0x3800	0x00		 0x3800 0x00			 0x3800 0x00					 0x3800 0x00	  0x3800	0x00 
	
	
	
		write_cmos_sensor(0x0104, 0x00);//group
		write_cmos_sensor(0x0100, 0x01);//STREAM ON
		// The register only need to enable 1 time.    
	}


/*************************************************************************
* FUNCTION
*	get_imgsensor_id
*
* DESCRIPTION
*	This function get the sensor ID 
*
* PARAMETERS
*	*sensorID : return the sensor ID 
*
* RETURNS
*	None
*
* GLOBALS AFFECTED
*
*************************************************************************/
static kal_uint32 get_imgsensor_id(UINT32 *sensor_id) 
{
	kal_uint8 i = 0;
    int  retry = 1;
	//sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
	//while (imgsensor_info.i2c_addr_table[i] != 0xff) {
		spin_lock(&imgsensor_drv_lock);
		imgsensor.i2c_write_id = 0x20;//imgsensor_info.i2c_addr_table[i];
		spin_unlock(&imgsensor_drv_lock);
		do {
			*sensor_id = ((read_cmos_sensor(0x0016) << 8) | read_cmos_sensor(0x0017));
			if (*sensor_id == imgsensor_info.sensor_id) {				
				LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);	  
				break;
			}	
			LOG_INF("Read sensor id fail, id: 0x%x,0x%x\n", imgsensor.i2c_write_id,*sensor_id);
			retry--;
		} while(retry > 0);
		//i++;
		//retry = 2;
//	}
	if (*sensor_id != imgsensor_info.sensor_id) {
		// if Sensor ID is not correct, Must set *sensor_id to 0xFFFFFFFF 
		*sensor_id = 0xFFFFFFFF;
		//*sensor_id = imgsensor_info.sensor_id;
		//return ERROR_NONE;
		return ERROR_SENSOR_CONNECT_FAIL;
	}
	return ERROR_NONE;
}



/*************************************************************************
* FUNCTION
*	open
*
* DESCRIPTION
*	This function initialize the registers of CMOS sensor
*
* PARAMETERS
*	None
*
* RETURNS
*	None
*
* GLOBALS AFFECTED
*
*************************************************************************/
static kal_uint32 open(void)
{
	//const kal_uint8 i2c_addr[] = {IMGSENSOR_WRITE_ID_1, IMGSENSOR_WRITE_ID_2};
	kal_uint8 i = 0;
	kal_uint8 retry = 1;
	kal_uint16 sensor_id = 0; 
	LOG_INF("PLATFORM:MT6595,MIPI 2LANE\n");
	LOG_INF("preview 1280*960@30fps,864Mbps/lane; video 1280*960@30fps,864Mbps/lane; capture 5M@30fps,864Mbps/lane\n");
	
	//sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
	//while (imgsensor_info.i2c_addr_table[i] != 0xff) {
		spin_lock(&imgsensor_drv_lock);
		imgsensor.i2c_write_id = 0x20;//imgsensor_info.i2c_addr_table[i];
		spin_unlock(&imgsensor_drv_lock);
		do {
			sensor_id = ((read_cmos_sensor(0x0016) << 8) | read_cmos_sensor(0x0017));
			if (sensor_id == imgsensor_info.sensor_id) {				
				LOG_INF("i2c write id: 0x%x, sensor id: 0x%x,0x%x\n", imgsensor.i2c_write_id,sensor_id);	  
				break;
			}	
			LOG_INF("Read sensor id fail, id: 0x%x,0x%x\n", imgsensor.i2c_write_id,sensor_id);
			retry--;
		} while(retry > 0);
		//i++;
		//if (sensor_id == imgsensor_info.sensor_id)
		//	break;
		//retry = 2;
	//}		 
	if (imgsensor_info.sensor_id != sensor_id)
		return ERROR_SENSOR_CONNECT_FAIL;

	


	
	/* initail sequence write in  */
	sensor_init();

	spin_lock(&imgsensor_drv_lock);

	imgsensor.autoflicker_en= KAL_FALSE;
	imgsensor.sensor_mode = IMGSENSOR_MODE_INIT;
	imgsensor.shutter = 0x3D0;
	imgsensor.gain = 0x100;
	imgsensor.pclk = imgsensor_info.pre.pclk;
	imgsensor.frame_length = imgsensor_info.pre.framelength;
	imgsensor.line_length = imgsensor_info.pre.linelength;
	imgsensor.min_frame_length = imgsensor_info.pre.framelength;
	imgsensor.dummy_pixel = 0;
	imgsensor.dummy_line = 0;
	imgsensor.ihdr_en = 0;
	imgsensor.test_pattern = KAL_FALSE;
	imgsensor.current_fps = imgsensor_info.pre.max_framerate;
	spin_unlock(&imgsensor_drv_lock);

	return ERROR_NONE;
}	/*	open  */



/*************************************************************************
* FUNCTION
*	close
*
* DESCRIPTION
*	
*
* PARAMETERS
*	None
*
* RETURNS
*	None
*
* GLOBALS AFFECTED
*
*************************************************************************/
static kal_uint32 close(void)
{
	LOG_INF("E\n");

	/*No Need to implement this function*/ 
	
	return ERROR_NONE;
}	/*	close  */


/*************************************************************************
* FUNCTION
* preview
*
* DESCRIPTION
*	This function start the sensor preview.
*
* PARAMETERS
*	*image_window : address pointer of pixel numbers in one period of HSYNC
*  *sensor_config_data : address pointer of line numbers in one period of VSYNC
*
* RETURNS
*	None
*
* GLOBALS AFFECTED
*
*************************************************************************/
static kal_uint32 preview(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
{
	LOG_INF("E\n");

	spin_lock(&imgsensor_drv_lock);
	imgsensor.sensor_mode = IMGSENSOR_MODE_PREVIEW;
	imgsensor.pclk = imgsensor_info.pre.pclk;
	//imgsensor.video_mode = KAL_FALSE;
	imgsensor.line_length = imgsensor_info.pre.linelength;
	imgsensor.frame_length = imgsensor_info.pre.framelength; 
	imgsensor.min_frame_length = imgsensor_info.pre.framelength;
	imgsensor.current_fps = imgsensor.current_fps;
	imgsensor.autoflicker_en = KAL_FALSE;
	spin_unlock(&imgsensor_drv_lock);
	preview_setting();
	return ERROR_NONE;
}   /*  gainMIPIPreview   */

/*************************************************************************
* FUNCTION
*	capture
*
* DESCRIPTION
*	This function setup the CMOS sensor in capture MY_OUTPUT mode
*
* PARAMETERS
*
* RETURNS
*	None
*
* GLOBALS AFFECTED
*
*************************************************************************/
static kal_uint32 capture(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
						  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
{
	LOG_INF("E\n");
	spin_lock(&imgsensor_drv_lock);
	imgsensor.sensor_mode = IMGSENSOR_MODE_CAPTURE;
	if (imgsensor.current_fps == imgsensor_info.cap1.max_framerate) {//PIP capture: 24fps for less than 13M, 20fps for 16M,15fps for 20M
		imgsensor.pclk = imgsensor_info.cap1.pclk;
		imgsensor.line_length = imgsensor_info.cap1.linelength;
		imgsensor.frame_length = imgsensor_info.cap1.framelength;  
		imgsensor.min_frame_length = imgsensor_info.cap1.framelength;
		imgsensor.autoflicker_en = KAL_FALSE;
	} else {
		if (imgsensor.current_fps != imgsensor_info.cap.max_framerate)
			LOG_INF("Warning: current_fps %d fps is not support, so use cap1's setting: %d fps!\n",imgsensor_info.cap1.max_framerate/10);
		imgsensor.pclk = imgsensor_info.cap.pclk;
		imgsensor.line_length = imgsensor_info.cap.linelength;
		imgsensor.frame_length = imgsensor_info.cap.framelength;  
		imgsensor.min_frame_length = imgsensor_info.cap.framelength;
		imgsensor.autoflicker_en = KAL_FALSE;
	}

	spin_unlock(&imgsensor_drv_lock);

	capture_setting(imgsensor.current_fps); 
	
	
	return ERROR_NONE;
}	/* capture() */
static kal_uint32 normal_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
{
	LOG_INF("E\n");
	
	spin_lock(&imgsensor_drv_lock);
	imgsensor.sensor_mode = IMGSENSOR_MODE_VIDEO;
	imgsensor.pclk = imgsensor_info.normal_video.pclk;
	imgsensor.line_length = imgsensor_info.normal_video.linelength;
	imgsensor.frame_length = imgsensor_info.normal_video.framelength;  
	imgsensor.min_frame_length = imgsensor_info.normal_video.framelength;
	//imgsensor.current_fps = 300;
	imgsensor.autoflicker_en = KAL_FALSE;
	spin_unlock(&imgsensor_drv_lock);
	normal_video_setting(imgsensor.current_fps);
	
	
	return ERROR_NONE;
}   /*  gainMIPIPreview   */

static kal_uint32 hs_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
{
	LOG_INF("E\n");
	
	spin_lock(&imgsensor_drv_lock);
	imgsensor.sensor_mode = IMGSENSOR_MODE_HIGH_SPEED_VIDEO;
	imgsensor.pclk = imgsensor_info.hs_video.pclk;
	//imgsensor.video_mode = KAL_TRUE;
	imgsensor.line_length = imgsensor_info.hs_video.linelength;
	imgsensor.frame_length = imgsensor_info.hs_video.framelength; 
	imgsensor.min_frame_length = imgsensor_info.hs_video.framelength;
	imgsensor.dummy_line = 0;
	imgsensor.dummy_pixel = 0;
	//imgsensor.current_fps = 300;
	imgsensor.autoflicker_en = KAL_FALSE;
	spin_unlock(&imgsensor_drv_lock);
	hs_video_setting();
	
	return ERROR_NONE;
}   /*  imx134MIPIPreview   */

static kal_uint32 slim_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
{
	LOG_INF("E\n");
	
	spin_lock(&imgsensor_drv_lock);
	imgsensor.sensor_mode = IMGSENSOR_MODE_SLIM_VIDEO;
	imgsensor.pclk = imgsensor_info.slim_video.pclk;
	//imgsensor.video_mode = KAL_TRUE;
	imgsensor.line_length = imgsensor_info.slim_video.linelength;
	imgsensor.frame_length = imgsensor_info.slim_video.framelength; 
	imgsensor.min_frame_length = imgsensor_info.slim_video.framelength;
	imgsensor.dummy_line = 0;
	imgsensor.dummy_pixel = 0;
	//imgsensor.current_fps = 300;
	imgsensor.autoflicker_en = KAL_FALSE;
	spin_unlock(&imgsensor_drv_lock);
	slim_video_setting();
	
	return ERROR_NONE;
}   /*  S5K4H5YCMIPIPreview   */



static kal_uint32 get_resolution(MSDK_SENSOR_RESOLUTION_INFO_STRUCT *sensor_resolution)
{
	LOG_INF("E\n");
	sensor_resolution->SensorFullWidth = imgsensor_info.cap.grabwindow_width;
	sensor_resolution->SensorFullHeight = imgsensor_info.cap.grabwindow_height;
	
	sensor_resolution->SensorPreviewWidth = imgsensor_info.pre.grabwindow_width;
	sensor_resolution->SensorPreviewHeight = imgsensor_info.pre.grabwindow_height;

	sensor_resolution->SensorVideoWidth = imgsensor_info.normal_video.grabwindow_width;
	sensor_resolution->SensorVideoHeight = imgsensor_info.normal_video.grabwindow_height;		

	
	sensor_resolution->SensorHighSpeedVideoWidth	 = imgsensor_info.hs_video.grabwindow_width;
	sensor_resolution->SensorHighSpeedVideoHeight	 = imgsensor_info.hs_video.grabwindow_height;
	
//	sensor_resolution->SensorSlimVideoWidth	 = imgsensor_info.slim_video.grabwindow_width;
//	sensor_resolution->SensorSlimVideoHeight	 = imgsensor_info.slim_video.grabwindow_height;
	return ERROR_NONE;
}	/*	get_resolution	*/

static kal_uint32 get_info(MSDK_SCENARIO_ID_ENUM scenario_id,
					  MSDK_SENSOR_INFO_STRUCT *sensor_info,
					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
{
	LOG_INF("scenario_id = %d\n", scenario_id);

	
	//sensor_info->SensorVideoFrameRate = imgsensor_info.normal_video.max_framerate/10; /* not use */
	//sensor_info->SensorStillCaptureFrameRate= imgsensor_info.cap.max_framerate/10; /* not use */
	//imgsensor_info->SensorWebCamCaptureFrameRate= imgsensor_info.v.max_framerate; /* not use */

	sensor_info->SensorClockPolarity = SENSOR_CLOCK_POLARITY_LOW;
	sensor_info->SensorClockFallingPolarity = SENSOR_CLOCK_POLARITY_LOW; /* not use */
	sensor_info->SensorHsyncPolarity = SENSOR_CLOCK_POLARITY_LOW; // inverse with datasheet
	sensor_info->SensorVsyncPolarity = SENSOR_CLOCK_POLARITY_LOW;
	sensor_info->SensorInterruptDelayLines = 4; /* not use */
	sensor_info->SensorResetActiveHigh = FALSE; /* not use */
	sensor_info->SensorResetDelayCount = 5; /* not use */

	sensor_info->SensroInterfaceType = imgsensor_info.sensor_interface_type;

	sensor_info->SensorOutputDataFormat = imgsensor_info.sensor_output_dataformat;

	sensor_info->CaptureDelayFrame = imgsensor_info.cap_delay_frame; 
	sensor_info->PreviewDelayFrame = imgsensor_info.pre_delay_frame; 
	sensor_info->VideoDelayFrame = imgsensor_info.video_delay_frame;
//	sensor_info->HighSpeedVideoDelayFrame = imgsensor_info.hs_video_delay_frame;
//	sensor_info->SlimVideoDelayFrame = imgsensor_info.slim_video_delay_frame;

	sensor_info->SensorMasterClockSwitch = 0; /* not use */
	sensor_info->SensorDrivingCurrent = imgsensor_info.isp_driving_current;
	
	sensor_info->AEShutDelayFrame = imgsensor_info.ae_shut_delay_frame; 		 /* The frame of setting shutter default 0 for TG int */
	sensor_info->AESensorGainDelayFrame = imgsensor_info.ae_sensor_gain_delay_frame;	/* The frame of setting sensor gain */
	sensor_info->AEISPGainDelayFrame = imgsensor_info.ae_ispGain_delay_frame;	
	sensor_info->IHDR_Support = imgsensor_info.ihdr_support;
	sensor_info->IHDR_LE_FirstLine = imgsensor_info.ihdr_le_firstline;
	sensor_info->SensorModeNum = imgsensor_info.sensor_mode_num;
	
	sensor_info->SensorMIPILaneNumber = imgsensor_info.mipi_lane_num; 
	sensor_info->SensorClockFreq = imgsensor_info.mclk;
	sensor_info->SensorClockDividCount = 3; /* not use */
	sensor_info->SensorClockRisingCount = 0;
	sensor_info->SensorClockFallingCount = 2; /* not use */
	sensor_info->SensorPixelClockCount = 3; /* not use */
	sensor_info->SensorDataLatchCount = 2; /* not use */
	
	sensor_info->MIPIDataLowPwr2HighSpeedTermDelayCount = 0; 
	sensor_info->MIPICLKLowPwr2HighSpeedTermDelayCount = 0;
	sensor_info->SensorWidthSampling = 0;  // 0 is default 1x
	sensor_info->SensorHightSampling = 0;	// 0 is default 1x 
	sensor_info->SensorPacketECCOrder = 1;

	switch (scenario_id) {
		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
			sensor_info->SensorGrabStartX = imgsensor_info.pre.startx; 
			sensor_info->SensorGrabStartY = imgsensor_info.pre.starty;		
			
			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.pre.mipi_data_lp2hs_settle_dc;
			
			break;
		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
			sensor_info->SensorGrabStartX = imgsensor_info.cap.startx; 
			sensor_info->SensorGrabStartY = imgsensor_info.cap.starty;
				  
			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.cap.mipi_data_lp2hs_settle_dc; 

			break;	 
		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
			
			sensor_info->SensorGrabStartX = imgsensor_info.normal_video.startx; 
			sensor_info->SensorGrabStartY = imgsensor_info.normal_video.starty;
	   
			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.normal_video.mipi_data_lp2hs_settle_dc; 

			break;	  
		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:			
			sensor_info->SensorGrabStartX = imgsensor_info.hs_video.startx; 
			sensor_info->SensorGrabStartY = imgsensor_info.hs_video.starty;
				  
			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.hs_video.mipi_data_lp2hs_settle_dc; 

			break;
		case MSDK_SCENARIO_ID_SLIM_VIDEO:
			sensor_info->SensorGrabStartX = imgsensor_info.slim_video.startx; 
			sensor_info->SensorGrabStartY = imgsensor_info.slim_video.starty;
				  
			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.slim_video.mipi_data_lp2hs_settle_dc; 

			break;
		default:			
			sensor_info->SensorGrabStartX = imgsensor_info.pre.startx; 
			sensor_info->SensorGrabStartY = imgsensor_info.pre.starty;		
			
			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.pre.mipi_data_lp2hs_settle_dc;
			break;
	}
	
	return ERROR_NONE;
}	/*	get_info  */


static kal_uint32 control(MSDK_SCENARIO_ID_ENUM scenario_id, MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
{
	LOG_INF("scenario_id = %d\n", scenario_id);
	spin_lock(&imgsensor_drv_lock);
	imgsensor.current_scenario_id = scenario_id;
	spin_unlock(&imgsensor_drv_lock);
	switch (scenario_id) {
		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
			preview(image_window, sensor_config_data);
			break;
		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
			capture(image_window, sensor_config_data);
			break;	
		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
			normal_video(image_window, sensor_config_data);
			break;	  
		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
			hs_video(image_window, sensor_config_data);
			break;
		case MSDK_SCENARIO_ID_SLIM_VIDEO:
			slim_video(image_window, sensor_config_data);
			break;	  
		default:
			LOG_INF("Error ScenarioId setting");
			preview(image_window, sensor_config_data);
			return ERROR_INVALID_SCENARIO_ID;
	}
	return ERROR_NONE;
}	/* control() */



static kal_uint32 set_video_mode(UINT16 framerate)
	{
		LOG_INF("framerate = %d\n ", framerate);
		// SetVideoMode Function should fix framerate
		if (framerate == 0)
			// Dynamic frame rate
			return ERROR_NONE;
		spin_lock(&imgsensor_drv_lock);
		if ((framerate == 300) && (imgsensor.autoflicker_en == KAL_TRUE))
			imgsensor.current_fps = 296;
		else if ((framerate == 150) && (imgsensor.autoflicker_en == KAL_TRUE))
			imgsensor.current_fps = 146;
		else
			imgsensor.current_fps = framerate;
		spin_unlock(&imgsensor_drv_lock);
		set_max_framerate(imgsensor.current_fps,1);
	
		return ERROR_NONE;
	}


static kal_uint32 set_auto_flicker_mode(kal_bool enable, UINT16 framerate)
{
	LOG_INF("enable = %d, framerate = %d \n", enable, framerate);
	spin_lock(&imgsensor_drv_lock);
	if (enable) //enable auto flicker	  
		imgsensor.autoflicker_en = KAL_TRUE;
	else //Cancel Auto flick
		imgsensor.autoflicker_en = KAL_FALSE;
	spin_unlock(&imgsensor_drv_lock);
	return ERROR_NONE;
}


static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 framerate) 
{
	kal_int16 dummyLine;
	kal_uint32 lineLength,frameHeight;
  
	LOG_INF("scenario_id = %d, framerate = %d\n", scenario_id, framerate);

	switch (scenario_id) {
		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
			frameHeight = imgsensor_info.pre.pclk / framerate * 10 / imgsensor_info.pre.linelength;
			spin_lock(&imgsensor_drv_lock);
			imgsensor.dummy_line = frameHeight - imgsensor_info.pre.framelength;
			if (imgsensor.dummy_line < 0)
				imgsensor.dummy_line = 0;
			imgsensor.frame_length += imgsensor.dummy_line;
			imgsensor.min_frame_length = imgsensor.frame_length;
			spin_unlock(&imgsensor_drv_lock);
			set_dummy();			
			break;			
		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
			if(framerate == 0)
				return ERROR_NONE;
			frameHeight = imgsensor_info.normal_video.pclk / framerate * 10 / imgsensor_info.normal_video.linelength;
			spin_lock(&imgsensor_drv_lock);
			imgsensor.dummy_line = frameHeight - imgsensor_info.normal_video.framelength;
			if (imgsensor.dummy_line < 0)
				imgsensor.dummy_line = 0;			
			imgsensor.frame_length += imgsensor.dummy_line;
			imgsensor.min_frame_length = imgsensor.frame_length;
			spin_unlock(&imgsensor_drv_lock);
			set_dummy();			
			break;
		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
		//case MSDK_SCENARIO_ID_CAMERA_ZSD:			
			frameHeight = imgsensor_info.cap.pclk / framerate * 10 / imgsensor_info.cap.linelength;
			spin_lock(&imgsensor_drv_lock);
			imgsensor.dummy_line = frameHeight - imgsensor_info.cap.framelength;
			if (imgsensor.dummy_line < 0)
				imgsensor.dummy_line = 0;
			imgsensor.frame_length += imgsensor.dummy_line;
			imgsensor.min_frame_length = imgsensor.frame_length;
			spin_unlock(&imgsensor_drv_lock);
			set_dummy();			
			break;	
		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
			frameHeight = imgsensor_info.hs_video.pclk / framerate * 10 / imgsensor_info.hs_video.linelength;
			spin_lock(&imgsensor_drv_lock);
			imgsensor.dummy_line = frameHeight - imgsensor_info.hs_video.framelength;
			if (imgsensor.dummy_line < 0)
				imgsensor.dummy_line = 0;
			imgsensor.min_frame_length = imgsensor.frame_length;
			spin_unlock(&imgsensor_drv_lock);
			set_dummy();			
			break;
		case MSDK_SCENARIO_ID_SLIM_VIDEO:
			frameHeight = imgsensor_info.slim_video.pclk / framerate * 10 / imgsensor_info.slim_video.linelength;
			spin_lock(&imgsensor_drv_lock);
			imgsensor.dummy_line = frameHeight - imgsensor_info.slim_video.framelength;
			if (imgsensor.dummy_line < 0)
				imgsensor.dummy_line = 0;			
			imgsensor.frame_length += imgsensor.dummy_line;
			imgsensor.min_frame_length = imgsensor.frame_length;
			spin_unlock(&imgsensor_drv_lock);
			set_dummy();			
		default:  //coding with  preview scenario by default
			frameHeight = imgsensor_info.pre.pclk / framerate * 10 / imgsensor_info.pre.linelength;
			spin_lock(&imgsensor_drv_lock);
			imgsensor.dummy_line = frameHeight - imgsensor_info.pre.framelength;
			if (imgsensor.dummy_line < 0)
				imgsensor.dummy_line = 0;
			imgsensor.frame_length += imgsensor.dummy_line;
			imgsensor.min_frame_length = imgsensor.frame_length;
			spin_unlock(&imgsensor_drv_lock);
			set_dummy();	
			LOG_INF("error scenario_id = %d, we use preview scenario \n", scenario_id);
			break;
	}	
	return ERROR_NONE;
}


static kal_uint32 get_default_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 *framerate) 
{
	LOG_INF("scenario_id = %d\n", scenario_id);

	switch (scenario_id) {
		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
			*framerate = imgsensor_info.pre.max_framerate;
			break;
		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
			*framerate = imgsensor_info.normal_video.max_framerate;
			break;
		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
			*framerate = imgsensor_info.cap.max_framerate;
			break;		
		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
			*framerate = imgsensor_info.hs_video.max_framerate;
			break;
		case MSDK_SCENARIO_ID_SLIM_VIDEO: 
			*framerate = imgsensor_info.slim_video.max_framerate;
			break;
		default:
			break;
	}

	return ERROR_NONE;
}

static kal_uint32 set_test_pattern_mode(kal_bool enable)
{
	LOG_INF("enable: %d\n", enable);

	if(enable) 	 
		write_cmos_sensor(0x0601, 0x02);
	else		  
		write_cmos_sensor(0x0601, 0x00);  

	spin_lock(&imgsensor_drv_lock);
	imgsensor.test_pattern = enable;
	spin_unlock(&imgsensor_drv_lock);
	return ERROR_NONE;
}

static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
							 UINT8 *feature_para,UINT32 *feature_para_len)
{
	UINT16 *feature_return_para_16=(UINT16 *) feature_para;
	UINT16 *feature_data_16=(UINT16 *) feature_para;
	UINT32 *feature_return_para_32=(UINT32 *) feature_para;
	UINT32 *feature_data_32=(UINT32 *) feature_para;
	
	SENSOR_WINSIZE_INFO_STRUCT *wininfo;	
	MSDK_SENSOR_REG_INFO_STRUCT *sensor_reg_data=(MSDK_SENSOR_REG_INFO_STRUCT *) feature_para;
 
	LOG_INF("feature_id = %d\n", feature_id);
	switch (feature_id) {
		case SENSOR_FEATURE_GET_PERIOD:
			*feature_return_para_16++ = imgsensor.line_length;
			*feature_return_para_16 = imgsensor.frame_length;
			*feature_para_len=4;
			break;
		case SENSOR_FEATURE_GET_PIXEL_CLOCK_FREQ:	 
			*feature_return_para_32 = imgsensor.pclk;
			*feature_para_len=4;
			break;		   
		case SENSOR_FEATURE_SET_ESHUTTER:
			set_shutter(*feature_data_16);
			break;
		case SENSOR_FEATURE_SET_NIGHTMODE:
			night_mode((BOOL) *feature_data_16);
			break;
		case SENSOR_FEATURE_SET_GAIN:		
			set_gain((UINT16) *feature_data_16);
			break;
		case SENSOR_FEATURE_SET_FLASHLIGHT:
			break;
		case SENSOR_FEATURE_SET_ISP_MASTER_CLOCK_FREQ:
			break;
		case SENSOR_FEATURE_SET_REGISTER:
			write_cmos_sensor(sensor_reg_data->RegAddr, sensor_reg_data->RegData);
			break;
		case SENSOR_FEATURE_GET_REGISTER:
			sensor_reg_data->RegData = read_cmos_sensor(sensor_reg_data->RegAddr);
			break;
		case SENSOR_FEATURE_GET_LENS_DRIVER_ID:
			// get the lens driver ID from EEPROM or just return LENS_DRIVER_ID_DO_NOT_CARE
			// if EEPROM does not exist in camera module.
			*feature_return_para_32=LENS_DRIVER_ID_DO_NOT_CARE;
			*feature_para_len=4;
			break;
		case SENSOR_FEATURE_SET_VIDEO_MODE:
			set_video_mode(*feature_data_16);
			break; 
		case SENSOR_FEATURE_CHECK_SENSOR_ID:
			get_imgsensor_id(feature_return_para_32); 
			break; 
		case SENSOR_FEATURE_SET_AUTO_FLICKER_MODE:
			set_auto_flicker_mode((BOOL)*feature_data_16,*(feature_data_16+1));
			break;
		case SENSOR_FEATURE_SET_MAX_FRAME_RATE_BY_SCENARIO:
			set_max_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*feature_data_32, *(feature_data_32+1));
			break;
		case SENSOR_FEATURE_GET_DEFAULT_FRAME_RATE_BY_SCENARIO:
			get_default_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*feature_data_32, (MUINT32 *)(*(feature_data_32+1)));
			break;
		case SENSOR_FEATURE_SET_TEST_PATTERN:
			set_test_pattern_mode((BOOL)*feature_data_16);
			break;
		case SENSOR_FEATURE_GET_TEST_PATTERN_CHECKSUM_VALUE: //for factory mode auto testing			 
			*feature_return_para_32 = imgsensor_info.checksum_value;
			*feature_para_len=4;							 
			break;				
		case SENSOR_FEATURE_SET_FRAMERATE:
			LOG_INF("current fps :%d\n", *feature_data_16);
			spin_lock(&imgsensor_drv_lock);
			imgsensor.current_fps = *feature_data_16;
			spin_unlock(&imgsensor_drv_lock);		
			break;
//		case SENSOR_FEATURE_SET_HDR:
	//		LOG_INF("ihdr enable :%d\n", *feature_data_16);
	//		spin_lock(&imgsensor_drv_lock);
//			imgsensor.ihdr_en = *feature_data_16;
	//		spin_unlock(&imgsensor_drv_lock);		
//			break;
		case SENSOR_FEATURE_GET_CROP_INFO:
			LOG_INF("SENSOR_FEATURE_GET_CROP_INFO scenarioId:%d\n", *feature_data_32);
			wininfo = (SENSOR_WINSIZE_INFO_STRUCT *)(*(feature_data_32+1));
		
			switch (*feature_data_32) {
				case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[1],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
					break;	  
				case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[2],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
					break;
				case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[3],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
					break;
				case MSDK_SCENARIO_ID_SLIM_VIDEO:
					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[4],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
					break;
				case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
				default:
					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[0],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
					break;
			}
		case SENSOR_FEATURE_SET_IHDR_SHUTTER_GAIN:
			LOG_INF("SENSOR_SET_SENSOR_IHDR LE=%d, SE=%d, Gain=%d\n",*feature_data_32,*(feature_data_32+1),*(feature_data_32+2)); 
			ihdr_write_shutter_gain(*feature_data_32,*(feature_data_32+1),*(feature_data_32+2));	
			break;
		default:
			break;
	}
  
	return ERROR_NONE;
}	/*	feature_control()  */

static SENSOR_FUNCTION_STRUCT sensor_func = {
	open,
	get_info,
	get_resolution,
	feature_control,
	control,
	close
};

UINT32 IMX134_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc)
{
	/* To Do : Check Sensor status here */
	if (pfFunc!=NULL)
		*pfFunc=&sensor_func;
	return ERROR_NONE;
}	/*	S5K4H5YC_MIPI_RAW_SensorInit	*/
